Compute Free(1, 0)
If select 1 in Tree A #Subproblem: 5 Direction: Right
Compute Free(1, 1)
If select 1 in Tree A #Subproblem: 2 Direction: Left
Compute Free(1, 2)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 2)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(1, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(1, 1)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 3)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 3)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(1, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(1, 0)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(2, 0)
If select 2 in Tree A #Subproblem: 5 Direction: Right
Compute Free(2, 1)
If select 2 in Tree A #Subproblem: 2 Direction: Left
Compute Free(2, 2)
If select 2 in Tree A #Subproblem: 1 Direction: Left
Compute Free(2, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(2, 2)
Keynode: 2 in Tree A
Direction: rightLeaf: 2
Compute Free(2, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(2, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(2, 1)
Keynode: 2 in Tree A
Direction: rightLeaf: 2
Compute Free(2, 3)
If select 2 in Tree A #Subproblem: 1 Direction: Left
Compute Free(2, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(2, 3)
Keynode: 2 in Tree A
Direction: rightLeaf: 2
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(2, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(2, 0)
Keynode: 2 in Tree A
Direction: rightLeaf: 2
Compute Free(4, 0)
If select 4 in Tree A #Subproblem: 5 Direction: Right
Compute Free(4, 1)
If select 4 in Tree A #Subproblem: 2 Direction: Left
Compute Free(4, 2)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 2)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(4, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(4, 1)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 3)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 3)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(4, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(4, 0)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(3, 2)
If select 2 in Tree B #Subproblem: 2 Direction: Left
Compute Free(3, 2)
If select 4(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(3, 2)
If select 4(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(3, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
Compute Free(3, 1)
If select 4(leftmost) in Tree A #Subproblem: 4 Direction: Right
Compute Free(3, 1)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
Compute Free(3, 1)
If select 2(leftmost) in Tree B #Subproblem: 4 Direction: Right
Compute Free(3, 1)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(3, 1)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(3, 3)
If select 3 in Tree B #Subproblem: 2 Direction: Left
Compute Free(3, 3)
If select 4(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(3, 3)
If select 4(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(3, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
Compute Free(3, 0)
If select 4(leftmost) in Tree A #Subproblem: 10 Direction: Right
Compute Free(3, 0)
If select 4(rightmost) in Tree A #Subproblem: 12 Direction: Left
Compute Free(3, 0)
If select 1(leftmost) in Tree B #Subproblem: 10 Direction: Right
Compute Free(3, 0)
If select 3(rightmost) in Tree B #Subproblem: 12 Direction: Left
FreeS(3, 0)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(5, 0)
If select 5 in Tree A #Subproblem: 5 Direction: Right
Compute Free(5, 1)
If select 5 in Tree A #Subproblem: 2 Direction: Left
Compute Free(5, 2)
If select 5 in Tree A #Subproblem: 1 Direction: Left
Compute Free(5, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(5, 2)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(5, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(5, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(5, 1)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(5, 3)
If select 5 in Tree A #Subproblem: 1 Direction: Left
Compute Free(5, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(5, 3)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(5, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(5, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(5, 0)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(6, 0)
If select 6 in Tree A #Subproblem: 5 Direction: Right
Compute Free(6, 1)
If select 6 in Tree A #Subproblem: 2 Direction: Left
Compute Free(6, 2)
If select 6 in Tree A #Subproblem: 1 Direction: Left
Compute Free(6, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(6, 2)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(6, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(6, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(6, 1)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(6, 3)
If select 6 in Tree A #Subproblem: 1 Direction: Left
Compute Free(6, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(6, 3)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(6, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(6, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(6, 0)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(7, 0)
If select 7 in Tree A #Subproblem: 5 Direction: Right
Compute Free(7, 1)
If select 7 in Tree A #Subproblem: 2 Direction: Left
Compute Free(7, 2)
If select 7 in Tree A #Subproblem: 1 Direction: Left
Compute Free(7, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(7, 2)
Keynode: 7 in Tree A
Direction: rightLeaf: 7
Compute Free(7, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(7, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(7, 1)
Keynode: 7 in Tree A
Direction: rightLeaf: 7
Compute Free(7, 3)
If select 7 in Tree A #Subproblem: 1 Direction: Left
Compute Free(7, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(7, 3)
Keynode: 7 in Tree A
Direction: rightLeaf: 7
Compute Free(7, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(7, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(7, 0)
Keynode: 7 in Tree A
Direction: rightLeaf: 7
Compute Free(0, 2)
If select 2 in Tree B #Subproblem: 14 Direction: Left
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 14 Direction: Right
Compute Free(0, 2)
If select 2 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 2)
If select 3 in Tree A #Subproblem: 13 Direction: Left
Compute Free(0, 2)
If select 5 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 2)
If select 6 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 2)
If select 7(rightmost) in Tree A #Subproblem: 14 Direction: Left
FreeS(0, 2)
Keynode: 3 in Tree A
Direction: left
Leaf: 4
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 28 Direction: Right
Compute Free(0, 1)
If select 2 in Tree A #Subproblem: 28 Direction: Left
Compute Free(0, 1)
If select 3 in Tree A #Subproblem: 26 Direction: Left
Compute Free(0, 1)
If select 5 in Tree A #Subproblem: 28 Direction: Left
Compute Free(0, 1)
If select 6 in Tree A #Subproblem: 28 Direction: Left
Compute Free(0, 1)
If select 7(rightmost) in Tree A #Subproblem: 28 Direction: Left
Compute Free(0, 1)
If select 2(leftmost) in Tree B #Subproblem: 28 Direction: Right
Compute Free(0, 1)
If select 2(rightmost) in Tree B #Subproblem: 28 Direction: Left
FreeS(0, 1)
Keynode: 3 in Tree A
Direction: left
Leaf: 4
Compute Free(0, 3)
If select 3 in Tree B #Subproblem: 14 Direction: Left
Compute Free(0, 3)
If select 1(leftmost) in Tree A #Subproblem: 14 Direction: Right
Compute Free(0, 3)
If select 2 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 3)
If select 3 in Tree A #Subproblem: 13 Direction: Left
Compute Free(0, 3)
If select 5 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 3)
If select 6 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 3)
If select 7(rightmost) in Tree A #Subproblem: 14 Direction: Left
FreeS(0, 3)
Keynode: 3 in Tree A
Direction: left
Leaf: 4
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 70 Direction: Right
Compute Free(0, 0)
If select 2 in Tree A #Subproblem: 72 Direction: Right
Compute Free(0, 0)
If select 3 in Tree A #Subproblem: 69 Direction: Right
Compute Free(0, 0)
If select 5 in Tree A #Subproblem: 75 Direction: Right
Compute Free(0, 0)
If select 6 in Tree A #Subproblem: 76 Direction: Right
Compute Free(0, 0)
If select 7(rightmost) in Tree A #Subproblem: 78 Direction: Left
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 69 Direction: Right
Compute Free(0, 0)
If select 3(rightmost) in Tree B #Subproblem: 82 Direction: Left
FreeS(0, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 4
RESULT
4 in A 4 in A 4 in A 4 in A 
1 in A 1 in A 1 in A 1 in A 
2 in A 2 in A 2 in A 2 in A 
4 in A 4 in A 2 in B 3 in B 
4 in A 4 in A 4 in A 4 in A 
5 in A 5 in A 5 in A 5 in A 
6 in A 6 in A 6 in A 6 in A 
7 in A 7 in A 7 in A 7 in A 
gted(0, 0)
treeSizeA = 8
treeSizeB = 4
gted(0, 0) create problem in A gted(4, 0)
gted(4, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(1, 0)
gted(1, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(2, 0)
gted(2, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(3, 0)
gted(3, 0)
treeSizeA = 2
treeSizeB = 4
gted(3, 0) create problem in A gted(4, 0)
gted(0, 0) create problem in A gted(5, 0)
gted(5, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(6, 0)
gted(6, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(7, 0)
gted(7, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
new Round B'
new Round C'
Right (4, 5, 3, 1)
Save to S[5, 1]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[4, 3]
T[3, 1] = S[5, 1]
new Round B'
new Round C'
Right (4, 5, 2, 3)
Save to S[5, 3]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[4, 2]
Right (4, 5, 2, 1)
Save to S[5, 1]
case1_case3 -2
case2_case3 s[5, 3]
case3_case d[4, 3]
D[3, 1] = S[5, 3]
Q[5] = S[5, 3]
T[2, 3] = S[5, 3]
T[2, 1] = S[5, 1]
new Round B'
new Round C'
Right (4, 5, 1, 2)
Save to S[5, 2]
case3 = 0
case1_case3 = -2
case2_case2 = q[5]
case3_case3 D[4, 1]
Right (4, 5, 1, 1)
Save to S[5, 1]
case1_case3 -3
case2_case3 s[5, 2]
case3_case d[4, 3]
D[3, 0] = S[5, 1]
Q[5] = S[5, 1]
T[1, 2] = S[5, 2]
T[1, 1] = S[5, 1]
new Round B'
new Round C'
Right (4, 5, 0, 0)
Save to S[5, 0]
case3 = 0
case1_case3 = -4
case2_case2 = q[5]
case3_case3 D[4, 0]
T[0, 0] = S[5, 0]
new Round B'
new Round C'
Right (3, 4, 3, 1)
Save to S[4, 1]
case3 = 0
case1_case2 = t[3, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[3, 3]
T[3, 1] = S[4, 1]
new Round B'
new Round C'
Right (3, 4, 2, 3)
Save to S[4, 3]
case3 = 0
case1_case2 = t[2, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[3, 2]
Right (3, 4, 2, 1)
Save to S[4, 1]
case1_case2 t[2, 1]
case2_case3 s[4, 3]
case3_case d[3, 3]
Q[4] = S[4, 3]
T[2, 3] = S[4, 3]
T[2, 1] = S[4, 1]
new Round B'
new Round C'
Right (3, 4, 1, 2)
Save to S[4, 2]
case3 = 0
case1_case2 = t[1, 2]
case2_case2 = q[4]
case3_case3 D[3, 1]
Right (3, 4, 1, 1)
Save to S[4, 1]
case1_case2 t[1, 1]
case2_case3 s[4, 2]
case3_case d[3, 3]
Q[4] = S[4, 1]
T[1, 2] = S[4, 2]
T[1, 1] = S[4, 1]
new Round B'
new Round C'
Right (3, 4, 0, 0)
Save to S[4, 0]
case3 = 0
case1_case2 = t[0, 0]
case2_case2 = q[4]
case3_case3 D[3, 0]
T[0, 0] = S[4, 0]
new Round B
new round C
Left (2, 4, 2, 3)
Save to S[2, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 3]
case2_case1 FcurrentForestCost
new round C
Left (1, 4, 2, 3)
Save to S[1, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 2]
case2_case1 FcurrentForestCost
rGminus1_in_preR = 2 rG = 3 parent_of_rG_in_preL = 1 parent_of_rG_in_preR = 2
Q[2] = S[2, 2]
Q[1] = S[1, 2]
T[2, 3] = S[1, 2]
new Round B
new round C
Left (2, 4, 1, 2)
Save to S[2, 1]
case3_case FcurrentForest - F(lF)
case1_case2 t[1, 2]
case2_case2 q[2]
new round C
Left (1, 4, 1, 2)
Save to S[1, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 1]
case2_case2 q[1]
rGminus1_in_preR = 1 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[1, 2] = S[1, 1]
new Round B
new round C
Left (2, 4, 3, 1)
Save to S[2, 3]
case3_case FcurrentForest - F(lF)
case1_case2 t[3, 1]
case2_case1 FcurrentForestCost
Left (2, 4, 2, 1)
Save to S[2, 2]
case1_case2 t[2, 1]
case2 s[2, 3]
case3 d[2, 2]
case3 t[3, 1]
Left (2, 4, 1, 1)
Save to S[2, 1]
case1_case2 t[1, 1]
case2 s[2, 2]
case3 d[2, 1]
case3 t[3, 1]
new round C
Left (1, 4, 3, 1)
Save to S[1, 3]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 3]
case2_case1 FcurrentForestCost
Left (1, 4, 2, 1)
Save to S[1, 2]
case1_case1 s[2, 2]
case2 s[1, 3]
case3 d[1, 2]
case3 s[2, 4]
Left (1, 4, 1, 1)
Save to S[1, 1]
case1_case1 s[2, 1]
case2 s[1, 2]
case3 d[1, 1]
case3 s[2, 4]
rGminus1_in_preR = 0 rG = 1 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
Q[2] = S[2, 1]
Q[1] = S[1, 1]
T[3, 1] = S[1, 3]
T[2, 1] = S[1, 2]
T[1, 1] = S[1, 1]
new Round B
new round C
Left (2, 4, 0, 0)
Save to S[2, 0]
case3_case FcurrentForest - F(lF)
case1_case2 t[0, 0]
case2_case2 q[2]
new round C
Left (1, 4, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 0]
case2_case2 q[1]
rGminus1_in_preR = 2147483647 rG = 0 parent_of_rG_in_preL = 2147483647 parent_of_rG_in_preR = 2147483647
T[0, 0] = S[1, 0]
new Round B'
new Round C'
Right (1, 3, 3, 1)
Save to S[3, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[5, 3]
new Round C'
Right (1, 2, 3, 1)
Save to S[2, 1]
case3_case FcurrentForest - F(rF)
case1_case1 = s[3, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[6, 3]
new Round C'
Right (1, 1, 3, 1)
Save to S[1, 1]
case3_case FcurrentForest - F(rF)
case1_case1 = s[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[7, 3]
new Round C'
Right (0, 0, 3, 1)
Save to S[0, 1]
case3 = 0
case1_case1 = s[1, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 3]
T[3, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 3, 2, 3)
Save to S[3, 3]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[5, 2]
Right (1, 3, 2, 1)
Save to S[3, 1]
case1_case2 t[2, 1]
case2_case3 s[3, 3]
case3_case d[5, 3]
new Round C'
Right (1, 2, 2, 3)
Save to S[2, 3]
case3_case FcurrentForest - F(rF)
case1_case1 = s[3, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[6, 2]
Right (1, 2, 2, 1)
Save to S[2, 1]
case1_case1 s[3, 1]
case2_case3 s[2, 3]
case3_case d[6, 3]
new Round C'
Right (1, 1, 2, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(rF)
case1_case1 = s[2, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[7, 2]
Right (1, 1, 2, 1)
Save to S[1, 1]
case1_case1 s[2, 1]
case2_case3 s[1, 3]
case3_case d[7, 3]
new Round C'
Right (0, 0, 2, 3)
Save to S[0, 3]
case3 = 0
case1_case1 = s[1, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 2]
Right (0, 0, 2, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 3]
case3_case d[0, 3]
D[0, 1] = S[0, 3]
Q[3] = S[3, 3]
Q[2] = S[2, 3]
Q[1] = S[1, 3]
Q[0] = S[0, 3]
T[2, 3] = S[0, 3]
T[2, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 3, 1, 2)
Save to S[3, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case2 = q[3]
case3_case3 D[5, 1]
Right (1, 3, 1, 1)
Save to S[3, 1]
case1_case2 t[1, 1]
case2_case3 s[3, 2]
case3_case d[5, 3]
new Round C'
Right (1, 2, 1, 2)
Save to S[2, 2]
case3_case FcurrentForest - F(rF)
case1_case1 = s[3, 2]
case2_case2 = q[2]
case3_case3 D[6, 1]
Right (1, 2, 1, 1)
Save to S[2, 1]
case1_case1 s[3, 1]
case2_case3 s[2, 2]
case3_case d[6, 3]
new Round C'
Right (1, 1, 1, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(rF)
case1_case1 = s[2, 2]
case2_case2 = q[1]
case3_case3 D[7, 1]
Right (1, 1, 1, 1)
Save to S[1, 1]
case1_case1 s[2, 1]
case2_case3 s[1, 2]
case3_case d[7, 3]
new Round C'
Right (0, 0, 1, 2)
Save to S[0, 2]
case3 = 0
case1_case1 = s[1, 2]
case2_case2 = q[0]
case3_case3 D[0, 1]
Right (0, 0, 1, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 2]
case3_case d[0, 3]
D[0, 0] = S[0, 1]
Q[3] = S[3, 1]
Q[2] = S[2, 1]
Q[1] = S[1, 1]
Q[0] = S[0, 1]
T[1, 2] = S[0, 2]
T[1, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 3, 0, 0)
Save to S[3, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[3]
case3_case3 D[5, 0]
new Round C'
Right (1, 2, 0, 0)
Save to S[2, 0]
case3_case FcurrentForest - F(rF)
case1_case1 = s[3, 0]
case2_case2 = q[2]
case3_case3 D[6, 0]
new Round C'
Right (1, 1, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(rF)
case1_case1 = s[2, 0]
case2_case2 = q[1]
case3_case3 D[7, 0]
new Round C'
Right (0, 0, 0, 0)
Save to S[0, 0]
case3 = 0
case1_case1 = s[1, 0]
case2_case2 = q[0]
case3_case3 D[0, 0]
T[0, 0] = S[0, 0]
