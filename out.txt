Compute Free(3, 0)
If select 3 in Tree A #Subproblem: 4 Direction: Left
Compute Free(3, 1)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 1)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 2)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
LeftB[3, 1] = 1
Compute Free(3, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(3, 2) = 1
Compute Free(3, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(3, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(4, 0)
If select 4 in Tree A #Subproblem: 4 Direction: Left
Compute Free(4, 1)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 1)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 2)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 2)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
LeftB[4, 1] = 1
Compute Free(4, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(4, 2) = 1
Compute Free(4, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(4, 0)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(2, 1)
If select 1 in Tree B #Subproblem: 4 Direction: Left
LeftA[3, 1] = 1
Compute Free(2, 1)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
RightA[4, 1] set to 4
Compute Free(2, 1)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
FreeS(2, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(2, 2)
If select 2 in Tree B #Subproblem: 4 Direction: Left
LeftA[3, 2] = 1
Compute Free(2, 2)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
RightA[4, 2] set to 4
Compute Free(2, 2)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
FreeS(2, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
LeftA[3, 0] = 4
Compute Free(2, 0)
If select 3(leftmost) in Tree A #Subproblem: 16 Direction: Right
RightA[4, 0] set to 4
Compute Free(2, 0)
If select 4(rightmost) in Tree A #Subproblem: 16 Direction: Left
LeftB[2, 1] = 4
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 16 Direction: Right
RightB(2, 2) = 4
Compute Free(2, 0)
If select 2(rightmost) in Tree B #Subproblem: 16 Direction: Left
FreeS(2, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(5, 0)
If select 5 in Tree A #Subproblem: 4 Direction: Left
Compute Free(5, 1)
If select 5 in Tree A #Subproblem: 1 Direction: Left
Compute Free(5, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(5, 1)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(5, 2)
If select 5 in Tree A #Subproblem: 1 Direction: Left
Compute Free(5, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(5, 2)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
LeftB[5, 1] = 1
Compute Free(5, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(5, 2) = 1
Compute Free(5, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(5, 0)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(6, 0)
If select 6 in Tree A #Subproblem: 4 Direction: Left
Compute Free(6, 1)
If select 6 in Tree A #Subproblem: 1 Direction: Left
Compute Free(6, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(6, 1)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(6, 2)
If select 6 in Tree A #Subproblem: 1 Direction: Left
Compute Free(6, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(6, 2)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
LeftB[6, 1] = 1
Compute Free(6, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(6, 2) = 1
Compute Free(6, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(6, 0)
Keynode: 6 in Tree A
Direction: rightLeaf: 6
Compute Free(1, 1)
If select 1 in Tree B #Subproblem: 9 Direction: Right
aleftmost = 2 + 2 = 4
LeftA[2, 1] = 4
Compute Free(1, 1)
If select 2(leftmost) in Tree A #Subproblem: 9 Direction: Right
Compute Free(1, 1)
If select 5 in Tree A #Subproblem: 11 Direction: Left
RightA[6, 1] set to 6
Compute Free(1, 1)
If select 6(rightmost) in Tree A #Subproblem: 11 Direction: Left
FreeS(1, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(1, 2)
If select 2 in Tree B #Subproblem: 9 Direction: Right
aleftmost = 2 + 2 = 4
LeftA[2, 2] = 4
Compute Free(1, 2)
If select 2(leftmost) in Tree A #Subproblem: 9 Direction: Right
Compute Free(1, 2)
If select 5 in Tree A #Subproblem: 11 Direction: Left
RightA[6, 2] set to 6
Compute Free(1, 2)
If select 6(rightmost) in Tree A #Subproblem: 11 Direction: Left
FreeS(1, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
aleftmost = 8 + 8 = 16
LeftA[2, 0] = 16
Compute Free(1, 0)
If select 2(leftmost) in Tree A #Subproblem: 36 Direction: Right
Compute Free(1, 0)
If select 5 in Tree A #Subproblem: 44 Direction: Left
RightA[6, 0] set to 6
Compute Free(1, 0)
If select 6(rightmost) in Tree A #Subproblem: 44 Direction: Left
LeftB[1, 1] = 9
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 36 Direction: Right
RightB(1, 2) = 11
Compute Free(1, 0)
If select 2(rightmost) in Tree B #Subproblem: 42 Direction: Left
FreeS(1, 0)
Keynode: 2 in Tree A
Direction: rightLeaf: 3
Compute Free(8, 0)
If select 8 in Tree A #Subproblem: 4 Direction: Left
Compute Free(8, 1)
If select 8 in Tree A #Subproblem: 1 Direction: Left
Compute Free(8, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(8, 1)
Keynode: 8 in Tree A
Direction: rightLeaf: 8
Compute Free(8, 2)
If select 8 in Tree A #Subproblem: 1 Direction: Left
Compute Free(8, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(8, 2)
Keynode: 8 in Tree A
Direction: rightLeaf: 8
LeftB[8, 1] = 1
Compute Free(8, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(8, 2) = 1
Compute Free(8, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(8, 0)
Keynode: 8 in Tree A
Direction: rightLeaf: 8
Compute Free(10, 0)
If select 10 in Tree A #Subproblem: 4 Direction: Left
Compute Free(10, 1)
If select 10 in Tree A #Subproblem: 1 Direction: Left
Compute Free(10, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(10, 1)
Keynode: 10 in Tree A
Direction: rightLeaf: 10
Compute Free(10, 2)
If select 10 in Tree A #Subproblem: 1 Direction: Left
Compute Free(10, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(10, 2)
Keynode: 10 in Tree A
Direction: rightLeaf: 10
LeftB[10, 1] = 1
Compute Free(10, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(10, 2) = 1
Compute Free(10, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(10, 0)
Keynode: 10 in Tree A
Direction: rightLeaf: 10
Compute Free(11, 0)
If select 11 in Tree A #Subproblem: 4 Direction: Left
Compute Free(11, 1)
If select 11 in Tree A #Subproblem: 1 Direction: Left
Compute Free(11, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(11, 1)
Keynode: 11 in Tree A
Direction: rightLeaf: 11
Compute Free(11, 2)
If select 11 in Tree A #Subproblem: 1 Direction: Left
Compute Free(11, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(11, 2)
Keynode: 11 in Tree A
Direction: rightLeaf: 11
LeftB[11, 1] = 1
Compute Free(11, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(11, 2) = 1
Compute Free(11, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(11, 0)
Keynode: 11 in Tree A
Direction: rightLeaf: 11
Compute Free(12, 0)
If select 12 in Tree A #Subproblem: 4 Direction: Left
Compute Free(12, 1)
If select 12 in Tree A #Subproblem: 1 Direction: Left
Compute Free(12, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(12, 1)
Keynode: 12 in Tree A
Direction: rightLeaf: 12
Compute Free(12, 2)
If select 12 in Tree A #Subproblem: 1 Direction: Left
Compute Free(12, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(12, 2)
Keynode: 12 in Tree A
Direction: rightLeaf: 12
LeftB[12, 1] = 1
Compute Free(12, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(12, 2) = 1
Compute Free(12, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(12, 0)
Keynode: 12 in Tree A
Direction: rightLeaf: 12
Compute Free(9, 1)
If select 1 in Tree B #Subproblem: 6 Direction: Left
LeftA[10, 1] = 1
Compute Free(9, 1)
If select 10(leftmost) in Tree A #Subproblem: 6 Direction: Right
Compute Free(9, 1)
If select 11 in Tree A #Subproblem: 6 Direction: Left
RightA[12, 1] set to 12
Compute Free(9, 1)
If select 12(rightmost) in Tree A #Subproblem: 6 Direction: Left
FreeS(9, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(9, 2)
If select 2 in Tree B #Subproblem: 6 Direction: Left
LeftA[10, 2] = 1
Compute Free(9, 2)
If select 10(leftmost) in Tree A #Subproblem: 6 Direction: Right
Compute Free(9, 2)
If select 11 in Tree A #Subproblem: 6 Direction: Left
RightA[12, 2] set to 12
Compute Free(9, 2)
If select 12(rightmost) in Tree A #Subproblem: 6 Direction: Left
FreeS(9, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
LeftA[10, 0] = 4
Compute Free(9, 0)
If select 10(leftmost) in Tree A #Subproblem: 24 Direction: Right
Compute Free(9, 0)
If select 11 in Tree A #Subproblem: 24 Direction: Left
RightA[12, 0] set to 12
Compute Free(9, 0)
If select 12(rightmost) in Tree A #Subproblem: 24 Direction: Left
LeftB[9, 1] = 6
Compute Free(9, 0)
If select 1(leftmost) in Tree B #Subproblem: 24 Direction: Right
RightB(9, 2) = 6
Compute Free(9, 0)
If select 2(rightmost) in Tree B #Subproblem: 24 Direction: Left
FreeS(9, 0)
Keynode: 10 in Tree A
Direction: rightLeaf: 10
Compute Free(13, 0)
If select 13 in Tree A #Subproblem: 4 Direction: Left
Compute Free(13, 1)
If select 13 in Tree A #Subproblem: 1 Direction: Left
Compute Free(13, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(13, 1)
Keynode: 13 in Tree A
Direction: rightLeaf: 13
Compute Free(13, 2)
If select 13 in Tree A #Subproblem: 1 Direction: Left
Compute Free(13, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(13, 2)
Keynode: 13 in Tree A
Direction: rightLeaf: 13
LeftB[13, 1] = 1
Compute Free(13, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(13, 2) = 1
Compute Free(13, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(13, 0)
Keynode: 13 in Tree A
Direction: rightLeaf: 13
Compute Free(7, 1)
If select 1 in Tree B #Subproblem: 14 Direction: Left
LeftA[8, 1] = 1
Compute Free(7, 1)
If select 8(leftmost) in Tree A #Subproblem: 14 Direction: Right
Compute Free(7, 1)
If select 9 in Tree A #Subproblem: 11 Direction: Left
RightA[13, 1] set to 13
Compute Free(7, 1)
If select 13(rightmost) in Tree A #Subproblem: 14 Direction: Left
FreeS(7, 1)
Keynode: 9 in Tree A
Direction: left
Leaf: 10
Compute Free(7, 2)
If select 2 in Tree B #Subproblem: 14 Direction: Left
LeftA[8, 2] = 1
Compute Free(7, 2)
If select 8(leftmost) in Tree A #Subproblem: 14 Direction: Right
Compute Free(7, 2)
If select 9 in Tree A #Subproblem: 11 Direction: Left
RightA[13, 2] set to 13
Compute Free(7, 2)
If select 13(rightmost) in Tree A #Subproblem: 14 Direction: Left
FreeS(7, 2)
Keynode: 9 in Tree A
Direction: left
Leaf: 10
LeftA[8, 0] = 4
Compute Free(7, 0)
If select 8(leftmost) in Tree A #Subproblem: 56 Direction: Right
Compute Free(7, 0)
If select 9 in Tree A #Subproblem: 44 Direction: Left
RightA[13, 0] set to 13
Compute Free(7, 0)
If select 13(rightmost) in Tree A #Subproblem: 56 Direction: Left
LeftB[7, 1] = 14
Compute Free(7, 0)
If select 1(leftmost) in Tree B #Subproblem: 53 Direction: Right
RightB(7, 2) = 14
Compute Free(7, 0)
If select 2(rightmost) in Tree B #Subproblem: 53 Direction: Left
FreeS(7, 0)
Keynode: 9 in Tree A
Direction: left
Leaf: 10
Compute Free(14, 0)
If select 14 in Tree A #Subproblem: 4 Direction: Left
Compute Free(14, 1)
If select 14 in Tree A #Subproblem: 1 Direction: Left
Compute Free(14, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(14, 1)
Keynode: 14 in Tree A
Direction: rightLeaf: 14
Compute Free(14, 2)
If select 14 in Tree A #Subproblem: 1 Direction: Left
Compute Free(14, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(14, 2)
Keynode: 14 in Tree A
Direction: rightLeaf: 14
LeftB[14, 1] = 1
Compute Free(14, 0)
If select 1(leftmost) in Tree B #Subproblem: 4 Direction: Right
RightB(14, 2) = 1
Compute Free(14, 0)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(14, 0)
Keynode: 14 in Tree A
Direction: rightLeaf: 14
Compute Free(0, 1)
If select 1 in Tree B #Subproblem: 33 Direction: Right
aleftmost = 6 + 3 = 9
LeftA[1, 1] = 9
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 30 Direction: Right
Compute Free(0, 1)
If select 7 in Tree A #Subproblem: 29 Direction: Left
RightA[14, 1] set to 14
Compute Free(0, 1)
If select 14(rightmost) in Tree A #Subproblem: 35 Direction: Left
FreeS(0, 1)
Keynode: 7 in Tree A
Direction: left
Leaf: 10
Compute Free(0, 2)
If select 2 in Tree B #Subproblem: 33 Direction: Right
aleftmost = 6 + 3 = 9
LeftA[1, 2] = 9
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 30 Direction: Right
Compute Free(0, 2)
If select 7 in Tree A #Subproblem: 29 Direction: Left
RightA[14, 2] set to 14
Compute Free(0, 2)
If select 14(rightmost) in Tree A #Subproblem: 35 Direction: Left
FreeS(0, 2)
Keynode: 7 in Tree A
Direction: left
Leaf: 10
aleftmost = 24 + 12 = 36
LeftA[1, 0] = 36
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 120 Direction: Right
Compute Free(0, 0)
If select 7 in Tree A #Subproblem: 116 Direction: Left
RightA[14, 0] set to 14
Compute Free(0, 0)
If select 14(rightmost) in Tree A #Subproblem: 140 Direction: Left
LeftB[0, 1] = 33
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 128 Direction: Right
RightB(0, 2) = 40
Compute Free(0, 0)
If select 2(rightmost) in Tree B #Subproblem: 149 Direction: Left
FreeS(0, 0)
Keynode: 7 in Tree A
Direction: left
Leaf: 10
3 is a leaf
set S[3, 1] = 3
set S[3, 2] = 3
set S[3, 0] = 3
compute 3, 1
parent i = 2 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 3 = 3 tmpCost = 1.000000
right leaf(i) in 3 = 3 tmpCost = 1.000000
S[2, 1] = S[3, 1] = 3
S[3, 1] = 1
compute 3, 2
parent i = 2 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 3 = 3 tmpCost = 1.000000
right leaf(i) in 3 = 3 tmpCost = 1.000000
S[2, 2] = S[3, 2] = 3
S[3, 2] = 2
compute 3, 0
parent i = 2 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 3 = 3 tmpCost = 4.000000
right leaf(i) in 3 = 3 tmpCost = 4.000000
special leaf(i) in 3 = 3 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[2, 0] = S[3, 0] = 3
S[3, 0] = 1
4 is a leaf
set S[4, 1] = 4
set S[4, 2] = 4
set S[4, 0] = 4
compute 4, 1
parent i = 2 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 4 = 4 tmpCost = 1.000000
right leaf(i) in 4 = 4 tmpCost = 1.000000
S[4, 1] = 1
compute 4, 2
parent i = 2 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 4 = 4 tmpCost = 1.000000
right leaf(i) in 4 = 4 tmpCost = 1.000000
S[4, 2] = 2
compute 4, 0
parent i = 2 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 4 = 4 tmpCost = 4.000000
right leaf(i) in 4 = 4 tmpCost = 4.000000
special leaf(i) in 4 = 4 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[4, 0] = 1
compute 2, 1
parent i = 1 parent j = 0
left leaf(i) in 2 = 3 tmpCost = 4.000000
right leaf(i) in 2 = 4 tmpCost = 4.000000
S[1, 1] = S[2, 1] = 3
S[2, 1] = 3
compute 2, 2
parent i = 1 parent j = 0
left leaf(i) in 2 = 3 tmpCost = 4.000000
right leaf(i) in 2 = 4 tmpCost = 4.000000
S[1, 2] = S[2, 2] = 3
S[2, 2] = 3
compute 2, 0
parent i = 1 parent j = NULL
left leaf(i) in 2 = 3 tmpCost = 16.000000
right leaf(i) in 2 = 4 tmpCost = 16.000000
special leaf(i) in 2 = 3 tmpCost = 16.000000
left leaf(j) in 0 = 1 tmpCost = 16.000000
right leaf(j) in 0 = 2 tmpCost = 16.000000
special leaf(j) in 0 = 1 tmpCost = 16.000000
S[1, 0] = S[2, 0] = 3
S[2, 0] = 3
5 is a leaf
set S[5, 1] = 5
set S[5, 2] = 5
set S[5, 0] = 5
compute 5, 1
parent i = 1 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 5 = 5 tmpCost = 1.000000
right leaf(i) in 5 = 5 tmpCost = 1.000000
S[5, 1] = 1
compute 5, 2
parent i = 1 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 5 = 5 tmpCost = 1.000000
right leaf(i) in 5 = 5 tmpCost = 1.000000
S[5, 2] = 2
compute 5, 0
parent i = 1 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 5 = 5 tmpCost = 4.000000
right leaf(i) in 5 = 5 tmpCost = 4.000000
special leaf(i) in 5 = 5 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[5, 0] = 1
6 is a leaf
set S[6, 1] = 6
set S[6, 2] = 6
set S[6, 0] = 6
compute 6, 1
parent i = 1 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 6 = 6 tmpCost = 1.000000
right leaf(i) in 6 = 6 tmpCost = 1.000000
S[6, 1] = 1
compute 6, 2
parent i = 1 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 6 = 6 tmpCost = 1.000000
right leaf(i) in 6 = 6 tmpCost = 1.000000
S[6, 2] = 2
compute 6, 0
parent i = 1 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 6 = 6 tmpCost = 4.000000
right leaf(i) in 6 = 6 tmpCost = 4.000000
special leaf(i) in 6 = 6 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[6, 0] = 1
compute 1, 1
parent i = 0 parent j = 0
left leaf(i) in 1 = 3 tmpCost = 9.000000
right leaf(i) in 1 = 6 tmpCost = 11.000000
S[0, 1] = S[1, 1] = 3
S[1, 1] = 3
compute 1, 2
parent i = 0 parent j = 0
left leaf(i) in 1 = 3 tmpCost = 9.000000
right leaf(i) in 1 = 6 tmpCost = 11.000000
S[0, 2] = S[1, 2] = 3
S[1, 2] = 3
compute 1, 0
parent i = 0 parent j = NULL
left leaf(i) in 1 = 3 tmpCost = 36.000000
right leaf(i) in 1 = 6 tmpCost = 44.000000
special leaf(i) in 1 = 3 tmpCost = 36.000000
left leaf(j) in 0 = 1 tmpCost = 36.000000
right leaf(j) in 0 = 2 tmpCost = 42.000000
special leaf(j) in 0 = 1 tmpCost = 51.000000
S[0, 0] = S[1, 0] = 3
S[1, 0] = 3
8 is a leaf
set S[8, 1] = 8
set S[8, 2] = 8
set S[8, 0] = 8
compute 8, 1
parent i = 7 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 8 = 8 tmpCost = 1.000000
right leaf(i) in 8 = 8 tmpCost = 1.000000
S[7, 1] = S[8, 1] = 8
S[8, 1] = 1
compute 8, 2
parent i = 7 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 8 = 8 tmpCost = 1.000000
right leaf(i) in 8 = 8 tmpCost = 1.000000
S[7, 2] = S[8, 2] = 8
S[8, 2] = 2
compute 8, 0
parent i = 7 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 8 = 8 tmpCost = 4.000000
right leaf(i) in 8 = 8 tmpCost = 4.000000
special leaf(i) in 8 = 8 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[7, 0] = S[8, 0] = 8
S[8, 0] = 1
10 is a leaf
set S[10, 1] = 10
set S[10, 2] = 10
set S[10, 0] = 10
compute 10, 1
parent i = 9 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 10 = 10 tmpCost = 1.000000
right leaf(i) in 10 = 10 tmpCost = 1.000000
S[9, 1] = S[10, 1] = 10
S[10, 1] = 1
compute 10, 2
parent i = 9 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 10 = 10 tmpCost = 1.000000
right leaf(i) in 10 = 10 tmpCost = 1.000000
S[9, 2] = S[10, 2] = 10
S[10, 2] = 2
compute 10, 0
parent i = 9 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 10 = 10 tmpCost = 4.000000
right leaf(i) in 10 = 10 tmpCost = 4.000000
special leaf(i) in 10 = 10 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[9, 0] = S[10, 0] = 10
S[10, 0] = 1
11 is a leaf
set S[11, 1] = 11
set S[11, 2] = 11
set S[11, 0] = 11
compute 11, 1
parent i = 9 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 11 = 11 tmpCost = 1.000000
right leaf(i) in 11 = 11 tmpCost = 1.000000
S[11, 1] = 1
compute 11, 2
parent i = 9 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 11 = 11 tmpCost = 1.000000
right leaf(i) in 11 = 11 tmpCost = 1.000000
S[11, 2] = 2
compute 11, 0
parent i = 9 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 11 = 11 tmpCost = 4.000000
right leaf(i) in 11 = 11 tmpCost = 4.000000
special leaf(i) in 11 = 11 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[11, 0] = 1
12 is a leaf
set S[12, 1] = 12
set S[12, 2] = 12
set S[12, 0] = 12
compute 12, 1
parent i = 9 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 12 = 12 tmpCost = 1.000000
right leaf(i) in 12 = 12 tmpCost = 1.000000
S[12, 1] = 1
compute 12, 2
parent i = 9 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 12 = 12 tmpCost = 1.000000
right leaf(i) in 12 = 12 tmpCost = 1.000000
S[12, 2] = 2
compute 12, 0
parent i = 9 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 12 = 12 tmpCost = 4.000000
right leaf(i) in 12 = 12 tmpCost = 4.000000
special leaf(i) in 12 = 12 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[12, 0] = 1
compute 9, 1
parent i = 7 parent j = 0
left leaf(i) in 9 = 10 tmpCost = 6.000000
right leaf(i) in 9 = 12 tmpCost = 6.000000
S[7, 1] = S[9, 1] = 10
S[9, 1] = 10
compute 9, 2
parent i = 7 parent j = 0
left leaf(i) in 9 = 10 tmpCost = 6.000000
right leaf(i) in 9 = 12 tmpCost = 6.000000
S[7, 2] = S[9, 2] = 10
S[9, 2] = 10
compute 9, 0
parent i = 7 parent j = NULL
left leaf(i) in 9 = 10 tmpCost = 24.000000
right leaf(i) in 9 = 12 tmpCost = 24.000000
special leaf(i) in 9 = 10 tmpCost = 24.000000
left leaf(j) in 0 = 1 tmpCost = 24.000000
right leaf(j) in 0 = 2 tmpCost = 24.000000
special leaf(j) in 0 = 1 tmpCost = 27.000000
S[7, 0] = S[9, 0] = 10
S[9, 0] = 10
13 is a leaf
set S[13, 1] = 13
set S[13, 2] = 13
set S[13, 0] = 13
compute 13, 1
parent i = 7 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 13 = 13 tmpCost = 1.000000
right leaf(i) in 13 = 13 tmpCost = 1.000000
S[13, 1] = 1
compute 13, 2
parent i = 7 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 13 = 13 tmpCost = 1.000000
right leaf(i) in 13 = 13 tmpCost = 1.000000
S[13, 2] = 2
compute 13, 0
parent i = 7 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 13 = 13 tmpCost = 4.000000
right leaf(i) in 13 = 13 tmpCost = 4.000000
special leaf(i) in 13 = 13 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[13, 0] = 1
compute 7, 1
parent i = 0 parent j = 0
left leaf(i) in 7 = 8 tmpCost = 14.000000
right leaf(i) in 7 = 13 tmpCost = 14.000000
S[0, 1] = S[7, 1] = 10
S[7, 1] = 8
compute 7, 2
parent i = 0 parent j = 0
left leaf(i) in 7 = 8 tmpCost = 14.000000
right leaf(i) in 7 = 13 tmpCost = 14.000000
S[0, 2] = S[7, 2] = 10
S[7, 2] = 8
compute 7, 0
parent i = 0 parent j = NULL
left leaf(i) in 7 = 8 tmpCost = 56.000000
right leaf(i) in 7 = 13 tmpCost = 56.000000
special leaf(i) in 7 = 10 tmpCost = 44.000000
left leaf(j) in 0 = 1 tmpCost = 56.000000
right leaf(j) in 0 = 2 tmpCost = 56.000000
special leaf(j) in 0 = 1 tmpCost = 71.000000
S[0, 0] = S[7, 0] = 10
S[7, 0] = 10
14 is a leaf
set S[14, 1] = 14
set S[14, 2] = 14
set S[14, 0] = 14
compute 14, 1
parent i = 0 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 14 = 14 tmpCost = 1.000000
right leaf(i) in 14 = 14 tmpCost = 1.000000
S[14, 1] = 1
compute 14, 2
parent i = 0 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 14 = 14 tmpCost = 1.000000
right leaf(i) in 14 = 14 tmpCost = 1.000000
S[14, 2] = 2
compute 14, 0
parent i = 0 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
left leaf(i) in 14 = 14 tmpCost = 4.000000
right leaf(i) in 14 = 14 tmpCost = 4.000000
special leaf(i) in 14 = 14 tmpCost = 4.000000
left leaf(j) in 0 = 1 tmpCost = 4.000000
right leaf(j) in 0 = 2 tmpCost = 4.000000
special leaf(j) in 0 = 1 tmpCost = 4.000000
S[14, 0] = 1
compute 0, 1
parent i = NULL parent j = 0
left leaf(i) in 0 = 3 tmpCost = 33.000000
right leaf(i) in 0 = 14 tmpCost = 40.000000
S[0, 1] = 3
compute 0, 2
parent i = NULL parent j = 0
left leaf(i) in 0 = 3 tmpCost = 33.000000
right leaf(i) in 0 = 14 tmpCost = 40.000000
S[0, 2] = 3
compute 0, 0
parent i = NULL parent j = NULL
left leaf(i) in 0 = 3 tmpCost = 120.000000
right leaf(i) in 0 = 14 tmpCost = 140.000000
special leaf(i) in 0 = 10 tmpCost = 116.000000
left leaf(j) in 0 = 1 tmpCost = 132.000000
right leaf(j) in 0 = 2 tmpCost = 153.000000
special leaf(j) in 0 = 1 tmpCost = 303.000000
S[0, 0] = 10
RESULT
10 in A 10 in A 10 in A 
3 in A 1 in B 2 in B 
3 in A 1 in B 2 in B 
3 in A 3 in A 3 in A 
4 in A 4 in A 4 in A 
5 in A 5 in A 5 in A 
6 in A 6 in A 6 in A 
10 in A 10 in A 10 in A 
8 in A 8 in A 8 in A 
10 in A 1 in B 2 in B 
10 in A 10 in A 10 in A 
11 in A 11 in A 11 in A 
12 in A 12 in A 12 in A 
13 in A 13 in A 13 in A 
14 in A 14 in A 14 in A 
RESULT 2
10 in A 3 in A 3 in A 
3 in A 3 in A 3 in A 
3 in A 3 in A 3 in A 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
10 in A 8 in A 8 in A 
1 in B 1 in B 2 in B 
10 in A 10 in A 10 in A 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
1 in B 1 in B 2 in B 
gted(0, 0)
treeSizeA = 15
treeSizeB = 3
getPathType A(0 ,10) = 2
A child = 10 currentPathNode = 10 parent = 9
A child = 11 currentPathNode = 10 parent = 9
gted(0, 0) create problem in A gted(11, 0)
gted(11, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 12 currentPathNode = 10 parent = 9
gted(0, 0) create problem in A gted(12, 0)
gted(12, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 8 currentPathNode = 9 parent = 7
gted(0, 0) create problem in A gted(8, 0)
gted(8, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 9 currentPathNode = 9 parent = 7
A child = 13 currentPathNode = 9 parent = 7
gted(0, 0) create problem in A gted(13, 0)
gted(13, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 1 currentPathNode = 7 parent = 0
gted(0, 0) create problem in A gted(1, 0)
gted(1, 0)
treeSizeA = 6
treeSizeB = 3
getPathType A(1 ,3) = 0
A child = 3 currentPathNode = 3 parent = 2
A child = 4 currentPathNode = 3 parent = 2
gted(1, 0) create problem in A gted(4, 0)
gted(4, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 2 currentPathNode = 2 parent = 1
A child = 5 currentPathNode = 2 parent = 1
gted(1, 0) create problem in A gted(5, 0)
gted(5, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
A child = 6 currentPathNode = 2 parent = 1
gted(1, 0) create problem in A gted(6, 0)
gted(6, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
swap = false pathType = 0
spfA(1, 0) 0
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (3, 14, 2, 1)
Save to S[14, 1]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 2]
T[2, 1] = S[14, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (3, 14, 1, 2)
Save to S[14, 2]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 1]
Right (3, 14, 1, 1)
Save to S[14, 1]
case1_case3 -2
case2_case3 s[14, 2]
case3_case d[3, 2]
case3_case2 GcurrentForestCost - G(rG) 
Q[14] = S[14, 1]
T[1, 2] = S[14, 2]
T[1, 1] = S[14, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (3, 14, 0, 0)
Save to S[14, 0]
case3 = 0
case1_case3 = -3
case2_case2 = q[14]
case3_case3 D[3, 0]
T[0, 0] = S[14, 0]
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (2, 13, 2, 1)
Save to S[13, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[4, 2]
new Round C'
Right (2, 12, 2, 1)
Save to S[12, 1]
case3 = 0
case1_case1 = s[13, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[2, 2]
T[2, 1] = S[12, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (2, 13, 1, 2)
Save to S[13, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[4, 1]
Right (2, 13, 1, 1)
Save to S[13, 1]
case1_case2 t[1, 1]
case2_case3 s[13, 2]
case3_case d[4, 2]
case3_case3 t[1, 2]
new Round C'
Right (2, 12, 1, 2)
Save to S[12, 2]
case3 = 0
case1_case1 = s[13, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[2, 1]
Right (2, 12, 1, 1)
Save to S[12, 1]
case1_case1 s[13, 1]
case2_case3 s[12, 2]
case3_case d[2, 2]
case3_case2 GcurrentForestCost - G(rG) 
save to D[2, 0] = S[12, 1]
Q[13] = S[13, 1]
Q[12] = S[12, 1]
T[1, 2] = S[12, 2]
T[1, 1] = S[12, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (2, 13, 0, 0)
Save to S[13, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[13]
case3_case3 D[4, 0]
new Round C'
Right (2, 12, 0, 0)
Save to S[12, 0]
case3 = 0
case1_case1 = s[13, 0]
case2_case2 = q[12]
case3_case3 D[2, 0]
T[0, 0] = S[12, 0]
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (1, 11, 2, 1)
Save to S[11, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[5, 2]
new Round C'
Right (1, 10, 2, 1)
Save to S[10, 1]
case3_case FcurrentForest - F(rF)
case1_case1 = s[11, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[6, 2]
new Round C'
Right (1, 9, 2, 1)
Save to S[9, 1]
case3 = 0
case1_case1 = s[10, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[1, 2]
T[2, 1] = S[9, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (1, 11, 1, 2)
Save to S[11, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[5, 1]
Right (1, 11, 1, 1)
Save to S[11, 1]
case1_case2 t[1, 1]
case2_case3 s[11, 2]
case3_case d[5, 2]
case3_case3 t[1, 2]
new Round C'
Right (1, 10, 1, 2)
Save to S[10, 2]
case3_case FcurrentForest - F(rF)
case1_case1 = s[11, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[6, 1]
Right (1, 10, 1, 1)
Save to S[10, 1]
case1_case1 s[11, 1]
case2_case3 s[10, 2]
case3_case d[6, 2]
case3_case1 s[11, 2]
new Round C'
Right (1, 9, 1, 2)
Save to S[9, 2]
case3 = 0
case1_case1 = s[10, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[1, 1]
Right (1, 9, 1, 1)
Save to S[9, 1]
case1_case1 s[10, 1]
case2_case3 s[9, 2]
case3_case d[1, 2]
case3_case2 GcurrentForestCost - G(rG) 
save to D[1, 0] = S[9, 1]
Q[11] = S[11, 1]
Q[10] = S[10, 1]
Q[9] = S[9, 1]
T[1, 2] = S[9, 2]
T[1, 1] = S[9, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (1, 11, 0, 0)
Save to S[11, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[11]
case3_case3 D[5, 0]
new Round C'
Right (1, 10, 0, 0)
Save to S[10, 0]
case3_case FcurrentForest - F(rF)
case1_case1 = s[11, 0]
case2_case2 = q[10]
case3_case3 D[6, 0]
new Round C'
Right (1, 9, 0, 0)
Save to S[9, 0]
case3 = 0
case1_case1 = s[10, 0]
case2_case2 = q[9]
case3_case3 D[1, 0]
T[0, 0] = S[9, 0]
A child = 7 currentPathNode = 7 parent = 0
A child = 14 currentPathNode = 7 parent = 0
gted(0, 0) create problem in A gted(14, 0)
gted(14, 0)
treeSizeA = 1
treeSizeB = 3
return 0.0f
swap = false pathType = 2
spfA(0, 0) 0
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (10, 7, 2, 1)
Save to S[7, 1]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[10, 2]
T[2, 1] = S[7, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (10, 7, 1, 2)
Save to S[7, 2]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[10, 1]
Right (10, 7, 1, 1)
Save to S[7, 1]
case1_case3 -2
case2_case3 s[7, 2]
case3_case d[10, 2]
case3_case2 GcurrentForestCost - G(rG) 
Q[7] = S[7, 1]
T[1, 2] = S[7, 2]
T[1, 1] = S[7, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (10, 7, 0, 0)
Save to S[7, 0]
case3 = 0
case1_case3 = -3
case2_case2 = q[7]
case3_case3 D[10, 0]
T[0, 0] = S[7, 0]
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (9, 6, 2, 1)
Save to S[6, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[11, 2]
new Round C'
Right (9, 5, 2, 1)
Save to S[5, 1]
case3_case FcurrentForest - F(rF)
case1_case1 = s[6, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[12, 2]
new Round C'
Right (9, 4, 2, 1)
Save to S[4, 1]
case3 = 0
case1_case1 = s[5, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[9, 2]
T[2, 1] = S[4, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (9, 6, 1, 2)
Save to S[6, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[11, 1]
Right (9, 6, 1, 1)
Save to S[6, 1]
case1_case2 t[1, 1]
case2_case3 s[6, 2]
case3_case d[11, 2]
case3_case3 t[1, 2]
new Round C'
Right (9, 5, 1, 2)
Save to S[5, 2]
case3_case FcurrentForest - F(rF)
case1_case1 = s[6, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[12, 1]
Right (9, 5, 1, 1)
Save to S[5, 1]
case1_case1 s[6, 1]
case2_case3 s[5, 2]
case3_case d[12, 2]
case3_case1 s[6, 2]
new Round C'
Right (9, 4, 1, 2)
Save to S[4, 2]
case3 = 0
case1_case1 = s[5, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[9, 1]
Right (9, 4, 1, 1)
Save to S[4, 1]
case1_case1 s[5, 1]
case2_case3 s[4, 2]
case3_case d[9, 2]
case3_case2 GcurrentForestCost - G(rG) 
save to D[9, 0] = S[4, 1]
Q[6] = S[6, 1]
Q[5] = S[5, 1]
Q[4] = S[4, 1]
T[1, 2] = S[4, 2]
T[1, 1] = S[4, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (9, 6, 0, 0)
Save to S[6, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[6]
case3_case3 D[11, 0]
new Round C'
Right (9, 5, 0, 0)
Save to S[5, 0]
case3_case FcurrentForest - F(rF)
case1_case1 = s[6, 0]
case2_case2 = q[5]
case3_case3 D[12, 0]
new Round C'
Right (9, 4, 0, 0)
Save to S[4, 0]
case3 = 0
case1_case1 = s[5, 0]
case2_case2 = q[4]
case3_case3 D[9, 0]
T[0, 0] = S[4, 0]
initial fn and ft endG = 0 endG + sizeG = 3
new Round B
O fn[1] = fn[16] = 1
O fn[16] = 1
ft[1] = -1
new round C
Left (8, 4, 1, 2)
Save to S[8, 1]
case3_case FcurrentForest - F(lF)
case1_case2 t[1, 2]
case2_case1 FcurrentForestCost
rGminus1_in_preR = 1 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[1, 2] = S[8, 1]
new Round B
fn[2] = fn[1] = 2
fn[1] = 2
ft[2] = 1
new round C
Left (8, 4, 2, 1)
Save to S[8, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 1]
case2_case1 FcurrentForestCost
Left (8, 4, 1, 1)
Save to S[8, 1]
case1_case2 t[1, 1]
case2 s[8, 2]
case3 d[8, 1]
case3 t[2, 1]
rGminus1_in_preR = 0 rG = 1 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
Q[8] = S[8, 1]
T[2, 1] = S[8, 2]
T[1, 1] = S[8, 1]
new Round B
O fn[0] = fn[16] = 0
O fn[16] = 0
ft[0] = -1
ft[fn[0]] = 0
new round C
Left (8, 4, 0, 0)
Save to S[8, 0]
case3_case FcurrentForest - F(lF)
case1_case2 t[0, 0]
case2_case2 q[8]
rGminus1_in_preR = 2147483647 rG = 0 parent_of_rG_in_preL = 2147483647 parent_of_rG_in_preR = 2147483647
T[0, 0] = S[8, 0]
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (8, 3, 2, 1)
Save to S[3, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[13, 2]
new Round C'
Right (7, 2, 2, 1)
Save to S[2, 1]
case3 = 0
case1_case1 = s[3, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[7, 2]
T[2, 1] = S[2, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (8, 3, 1, 2)
Save to S[3, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[13, 1]
Right (8, 3, 1, 1)
Save to S[3, 1]
case1_case2 t[1, 1]
case2_case3 s[3, 2]
case3_case d[13, 2]
case3_case3 t[1, 2]
new Round C'
Right (7, 2, 1, 2)
Save to S[2, 2]
case3 = 0
case1_case1 = s[3, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[7, 1]
Right (7, 2, 1, 1)
Save to S[2, 1]
case1_case1 s[3, 1]
case2_case3 s[2, 2]
case3_case d[7, 2]
case3_case2 GcurrentForestCost - G(rG) 
save to D[7, 0] = S[2, 1]
Q[3] = S[3, 1]
Q[2] = S[2, 1]
T[1, 2] = S[2, 2]
T[1, 1] = S[2, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (8, 3, 0, 0)
Save to S[3, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[3]
case3_case3 D[13, 0]
new Round C'
Right (7, 2, 0, 0)
Save to S[2, 0]
case3 = 0
case1_case1 = s[3, 0]
case2_case2 = q[2]
case3_case3 D[7, 0]
T[0, 0] = S[2, 0]
initial fn and ft endG = 0 endG + sizeG = 3
new Round B
O fn[1] = fn[16] = 1
O fn[16] = 1
ft[1] = -1
new round C
Left (6, 2, 1, 2)
Save to S[6, 1]
case3_case FcurrentForest - F(lF)
case1_case2 t[1, 2]
case2_case1 FcurrentForestCost
new round C
Left (5, 2, 1, 2)
Save to S[5, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[6, 1]
case2_case1 FcurrentForestCost
new round C
Left (4, 2, 1, 2)
Save to S[4, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[5, 1]
case2_case1 FcurrentForestCost
new round C
Left (3, 2, 1, 2)
Save to S[3, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[4, 1]
case2_case1 FcurrentForestCost
new round C
Left (2, 2, 1, 2)
Save to S[2, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[3, 1]
case2_case1 FcurrentForestCost
new round C
Left (1, 2, 1, 2)
Save to S[1, 1]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 1]
case2_case1 FcurrentForestCost
rGminus1_in_preR = 1 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[1, 2] = S[1, 1]
new Round B
fn[2] = fn[1] = 2
fn[1] = 2
ft[2] = 1
new round C
Left (6, 2, 2, 1)
Save to S[6, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 1]
case2_case1 FcurrentForestCost
Left (6, 2, 1, 1)
Save to S[6, 1]
case1_case2 t[1, 1]
case2 s[6, 2]
case3 d[6, 1]
case3 t[2, 1]
new round C
Left (5, 2, 2, 1)
Save to S[5, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[6, 2]
case2_case1 FcurrentForestCost
Left (5, 2, 1, 1)
Save to S[5, 1]
case1_case1 s[6, 1]
case2 s[5, 2]
case3 d[5, 1]
case3 s[6, 3]
new round C
Left (4, 2, 2, 1)
Save to S[4, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[5, 2]
case2_case1 FcurrentForestCost
Left (4, 2, 1, 1)
Save to S[4, 1]
case1_case1 s[5, 1]
case2 s[4, 2]
case3 d[4, 1]
case3 s[5, 3]
new round C
Left (3, 2, 2, 1)
Save to S[3, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[4, 2]
case2_case1 FcurrentForestCost
Left (3, 2, 1, 1)
Save to S[3, 1]
case1_case1 s[4, 1]
case2 s[3, 2]
case3 d[3, 1]
case3 s[4, 3]
new round C
Left (2, 2, 2, 1)
Save to S[2, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[3, 2]
case2_case1 FcurrentForestCost
Left (2, 2, 1, 1)
Save to S[2, 1]
case1_case1 s[3, 1]
case2 s[2, 2]
case3 d[2, 1]
case3 s[5, 3]
new round C
Left (1, 2, 2, 1)
Save to S[1, 2]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 2]
case2_case1 FcurrentForestCost
Left (1, 2, 1, 1)
Save to S[1, 1]
case1_case1 s[2, 1]
case2 s[1, 2]
case3 d[1, 1]
case3 t[2, 1]
rGminus1_in_preR = 0 rG = 1 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
Q[6] = S[6, 1]
Q[5] = S[5, 1]
Q[4] = S[4, 1]
Q[3] = S[3, 1]
Q[2] = S[2, 1]
Q[1] = S[1, 1]
T[2, 1] = S[1, 2]
T[1, 1] = S[1, 1]
new Round B
O fn[0] = fn[16] = 0
O fn[16] = 0
ft[0] = -1
ft[fn[0]] = 0
new round C
Left (6, 2, 0, 0)
Save to S[6, 0]
case3_case FcurrentForest - F(lF)
case1_case2 t[0, 0]
case2_case2 q[6]
new round C
Left (5, 2, 0, 0)
Save to S[5, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[6, 0]
case2_case2 q[5]
new round C
Left (4, 2, 0, 0)
Save to S[4, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[5, 0]
case2_case2 q[4]
new round C
Left (3, 2, 0, 0)
Save to S[3, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[4, 0]
case2_case2 q[3]
new round C
Left (2, 2, 0, 0)
Save to S[2, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[3, 0]
case2_case2 q[2]
new round C
Left (1, 2, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(lF)
case1_case1 s[2, 0]
case2_case2 q[1]
rGminus1_in_preR = 2147483647 rG = 0 parent_of_rG_in_preL = 2147483647 parent_of_rG_in_preR = 2147483647
T[0, 0] = S[1, 0]
initial fn and ft endG_in_preR = 0 endG_in_preR + sizeG = 3
new Round B'
updateFnArray(-1, 1, 0)
O fn[1] = fn[16] = 1
O fn[16] = 1
updateFtArray(-1, 1)
ft[1] = -1
new Round C'
Right (1, 1, 2, 1)
Save to S[1, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[14, 2]
new Round C'
Right (0, 0, 2, 1)
Save to S[0, 1]
case3 = 0
case1_case1 = s[1, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 2]
T[2, 1] = S[0, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1] = 2
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
new Round C'
Right (1, 1, 1, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[14, 1]
Right (1, 1, 1, 1)
Save to S[1, 1]
case1_case2 t[1, 1]
case2_case3 s[1, 2]
case3_case d[14, 2]
case3_case3 t[1, 2]
new Round C'
Right (0, 0, 1, 2)
Save to S[0, 2]
case3 = 0
case1_case1 = s[1, 2]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 1]
Right (0, 0, 1, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 2]
case3_case d[0, 2]
case3_case2 GcurrentForestCost - G(rG) 
save to D[0, 0] = S[0, 1]
Q[1] = S[1, 1]
Q[0] = S[0, 1]
T[1, 2] = S[0, 2]
T[1, 1] = S[0, 1]
new Round B'
updateFnArray(-1, 0, 0)
O fn[0] = fn[16] = 0
O fn[16] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
new Round C'
Right (1, 1, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[1]
case3_case3 D[14, 0]
new Round C'
Right (0, 0, 0, 0)
Save to S[0, 0]
case3 = 0
case1_case1 = s[1, 0]
case2_case2 = q[0]
case3_case3 D[0, 0]
T[0, 0] = S[0, 0]
