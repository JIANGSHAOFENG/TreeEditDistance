Compute Free(1, 0)
If select 1 in Tree A #Subproblem: 8 Direction: Left
Compute Free(1, 1)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 1)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 2)
If select 1 in Tree A #Subproblem: 2 Direction: Left
Compute Free(1, 3)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 3)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(1, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(1, 2)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 4)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 4)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
Compute Free(1, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
Compute Free(1, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
FreeS(1, 0)
Keynode: 2 in TreeB
Direction: left
Leaf: 3
Compute Free(3, 0)
If select 3 in Tree A #Subproblem: 8 Direction: Left
Compute Free(3, 1)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 1)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 2)
If select 3 in Tree A #Subproblem: 2 Direction: Left
Compute Free(3, 3)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 3)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(3, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(3, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 4)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 4)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
Compute Free(3, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
Compute Free(3, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
FreeS(3, 0)
Keynode: 2 in TreeB
Direction: left
Leaf: 3
Compute Free(2, 1)
If select 1 in Tree B #Subproblem: 2 Direction: Left
Compute Free(2, 1)
If select 3(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(2, 1)
If select 3(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(2, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(2, 3)
If select 3 in Tree B #Subproblem: 2 Direction: Left
Compute Free(2, 3)
If select 3(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(2, 3)
If select 3(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(2, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
Compute Free(2, 2)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
Compute Free(2, 2)
If select 3(rightmost) in Tree A #Subproblem: 4 Direction: Left
Compute Free(2, 2)
If select 3(leftmost) in Tree B #Subproblem: 4 Direction: Right
Compute Free(2, 2)
If select 3(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(2, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(2, 4)
If select 4 in Tree B #Subproblem: 2 Direction: Left
Compute Free(2, 4)
If select 3(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(2, 4)
If select 3(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(2, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
Compute Free(2, 0)
If select 3(leftmost) in Tree A #Subproblem: 16 Direction: Right
Compute Free(2, 0)
If select 3(rightmost) in Tree A #Subproblem: 16 Direction: Left
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 16 Direction: Right
Compute Free(2, 0)
If select 2 in Tree B #Subproblem: 14 Direction: Left
Compute Free(2, 0)
If select 4(rightmost) in Tree B #Subproblem: 16 Direction: Left
FreeS(2, 0)
Keynode: 2 in TreeB
Direction: left
Leaf: 3
Compute Free(4, 0)
If select 4 in Tree A #Subproblem: 8 Direction: Left
Compute Free(4, 1)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 1)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 2)
If select 4 in Tree A #Subproblem: 2 Direction: Left
Compute Free(4, 3)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 3)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(4, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(4, 2)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 4)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 4)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
Compute Free(4, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
Compute Free(4, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
FreeS(4, 0)
Keynode: 2 in TreeB
Direction: left
Leaf: 3
Compute Free(0, 1)
If select 1 in Tree B #Subproblem: 8 Direction: Left
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 8 Direction: Right
Compute Free(0, 1)
If select 2 in Tree A #Subproblem: 7 Direction: Left
Compute Free(0, 1)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
FreeS(0, 1)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 3)
If select 3 in Tree B #Subproblem: 8 Direction: Left
Compute Free(0, 3)
If select 1(leftmost) in Tree A #Subproblem: 8 Direction: Right
Compute Free(0, 3)
If select 2 in Tree A #Subproblem: 7 Direction: Left
Compute Free(0, 3)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
FreeS(0, 3)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 16 Direction: Right
Compute Free(0, 2)
If select 2 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 2)
If select 4(rightmost) in Tree A #Subproblem: 16 Direction: Left
Compute Free(0, 2)
If select 3(leftmost) in Tree B #Subproblem: 16 Direction: Right
Compute Free(0, 2)
If select 3(rightmost) in Tree B #Subproblem: 16 Direction: Left
FreeS(0, 2)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 4)
If select 4 in Tree B #Subproblem: 8 Direction: Left
Compute Free(0, 4)
If select 1(leftmost) in Tree A #Subproblem: 8 Direction: Right
Compute Free(0, 4)
If select 2 in Tree A #Subproblem: 7 Direction: Left
Compute Free(0, 4)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
FreeS(0, 4)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 61 Direction: Right
Compute Free(0, 0)
If select 2 in Tree A #Subproblem: 60 Direction: Left
Compute Free(0, 0)
If select 4(rightmost) in Tree A #Subproblem: 61 Direction: Left
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 61 Direction: Right
Compute Free(0, 0)
If select 2 in Tree B #Subproblem: 60 Direction: Left
Compute Free(0, 0)
If select 4(rightmost) in Tree B #Subproblem: 61 Direction: Left
FreeS(0, 0)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
RESULT
3 in A 3 in A 3 in A 3 in A 3 in A 
3 in B 1 in A 1 in A 1 in A 1 in A 
3 in B 1 in B 3 in A 3 in B 4 in B 
3 in B 3 in A 3 in A 3 in A 3 in A 
3 in B 4 in A 4 in A 4 in A 4 in A 
gted(0, 0)
treeSizeA = 5
treeSizeB = 5
gted(0, 0) create problem in A gted(3, 0)
gted(3, 0)
treeSizeA = 1
treeSizeB = 5
return 0.0f
gted(0, 0) create problem in A gted(1, 0)
gted(1, 0)
treeSizeA = 1
treeSizeB = 5
return 0.0f
gted(0, 0) create problem in A gted(2, 0)
gted(2, 0)
treeSizeA = 2
treeSizeB = 5
gted(2, 0) create problem in B gted(2, 3)
gted(2, 3)
treeSizeA = 2
treeSizeB = 1
return 0.0f
spfA(0, 2)
new Round B'
updateFnArray(1, 3, 2)
fn[3] = fn[6]
fn[6] = 3
updateFtArray(1, 3)
ft[3] = 1
ft[fn[3]] = 3
endG_in_preR = 2
start from rG = 3
FN
-1 0 -1 
FT
-1 1 -1 
new Round C'
Right (3, 3, 3, 3)
Save to S[3, 3]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 3]
D[2, 2] = S[3, 3]
Q[3] = S[3, 3]
T[3, 3] = S[3, 3]
new Round B'
updateFnArray(1, 2, 2)
fn[2] = fn[6]
fn[6] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 2
start from rG = 2
FN
3 0 -1 
FT
1 2 -1 
new Round C'
Right (3, 3, 2, 2)
Save to S[3, 2]
case3 = 0
case1_case3 = -2
case2_case2 = q[3]
case3_case3 D[2, 3]
T[2, 2] = S[3, 2]
new Round B'
updateFnArray(1, 3, 2)
fn[3] = fn[6]
fn[6] = 3
updateFtArray(1, 3)
ft[3] = 1
ft[fn[3]] = 3
endG_in_preR = 2
start from rG = 3
FN
-1 2 -1 
FT
3 1 -1 
new Round C'
Right (2, 2, 3, 3)
Save to S[2, 3]
case3 = 0
case1_case2 = t[3, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[3, 2]
Q[2] = S[2, 3]
T[3, 3] = S[2, 3]
new Round B'
updateFnArray(1, 2, 2)
fn[2] = fn[6]
fn[6] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 2
start from rG = 2
FN
3 2 -1 
FT
1 2 -1 
new Round C'
Right (2, 2, 2, 2)
Save to S[2, 2]
case3 = 0
case1_case2 = t[2, 2]
case2_case2 = q[2]
case3_case3 D[2, 2]
T[2, 2] = S[2, 2]
new Round B
fn[3] = fn[6]
fn[6] = 3
ft[3] = 1
ft[fn[3]] = 3
new round C
Left (1, 2, 3, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(lF)
case1_case2 t[3, 3]
case2_case1 FcurrentForestCost
rGminus1_in_preR = 2 rG = 3 parent_of_rG_in_preL = 2 parent_of_rG_in_preR = 2
Q[1] = S[1, 3]
T[3, 3] = S[1, 3]
new Round B
fn[2] = fn[6]
fn[6] = 2
ft[2] = 1
ft[fn[2]] = 2
new round C
Left (1, 2, 2, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 2]
case2_case2 q[1]
rGminus1_in_preR = 2147483647 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[2, 2] = S[1, 2]
new Round B'
updateFnArray(1, 3, 2)
fn[3] = fn[6]
fn[6] = 3
updateFtArray(1, 3)
ft[3] = 1
ft[fn[3]] = 3
endG_in_preR = 2
start from rG = 3
FN
-1 2 -1 
FT
3 1 -1 
new Round C'
Right (1, 1, 3, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[3, 4]
new Round C'
Right (0, 0, 3, 3)
Save to S[0, 3]
case3 = 0
case1_case1 = s[1, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[3, 0]
D[2, 0] = S[0, 3]
Q[1] = S[1, 3]
Q[0] = S[0, 3]
T[3, 3] = S[0, 3]
new Round B'
updateFnArray(1, 2, 2)
fn[2] = fn[6]
fn[6] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 2
start from rG = 2
FN
3 2 -1 
FT
1 2 -1 
new Round C'
Right (1, 1, 2, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 2]
case2_case2 = q[1]
case3_case3 D[2, 4]
new Round C'
Right (0, 0, 2, 2)
Save to S[0, 2]
case3 = 0
case1_case1 = s[1, 2]
case2_case2 = q[0]
case3_case3 D[2, 0]
T[2, 2] = S[0, 2]
gted(0, 0) create problem in A gted(4, 0)
gted(4, 0)
treeSizeA = 1
treeSizeB = 5
return 0.0f
spfA(0, 0)
new Round B'
updateFnArray(-1, 1, 0)
fn[1] = fn[6]
fn[6] = 1
updateFtArray(-1, 1)
ft[1] = -1
endG_in_preR = 0
start from rG = 1
FN
-1 -1 -1 -1 -1 -1 
FT
-1 -1 -1 -1 -1 -1 
new Round C'
Right (3, 3, 4, 1)
Save to S[3, 1]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 4]
T[4, 1] = S[3, 1]
new Round B'
updateFnArray(1, 3, 0)
fn[3] = fn[1]
fn[1] = 3
updateFtArray(1, 3)
ft[3] = 1
endG_in_preR = 0
start from rG = 3
FN
-1 3 -1 -1 -1 -1 
FT
-1 -1 -1 1 -1 -1 
new Round C'
Right (3, 3, 3, 3)
Save to S[3, 3]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 3]
Right (3, 3, 3, 1)
Save to S[3, 1]
case1_case3 -2
case2_case3 s[3, 3]
case3_case d[3, 4]
case3_case2 GcurrentForestCost - G(rG) 
D[2, 2] = S[3, 3]
Q[3] = S[3, 3]
T[3, 3] = S[3, 3]
T[3, 1] = S[3, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1]
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 0
start from rG = 2
FN
-1 2 3 -1 -1 -1 
FT
-1 -1 1 2 -1 -1 
new Round C'
Right (3, 3, 2, 2)
Save to S[3, 2]
case3 = 0
case1_case3 = -2
case2_case2 = q[3]
case3_case3 D[3, 2]
Right (3, 3, 2, 1)
Save to S[3, 1]
case1_case3 -3
case2_case3 s[3, 2]
case3_case d[3, 4]
case3_case2 GcurrentForestCost - G(rG) 
T[2, 2] = S[3, 2]
T[2, 1] = S[3, 1]
new Round B'
updateFnArray(3, 4, 0)
fn[4] = fn[3]
fn[3] = 4
updateFtArray(3, 4)
ft[4] = 3
endG_in_preR = 0
start from rG = 4
FN
-1 2 3 4 -1 -1 
FT
-1 -1 1 2 3 -1 
new Round C'
Right (3, 3, 1, 4)
Save to S[3, 4]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
case3_case3 D[3, 1]
Right (3, 3, 1, 3)
Save to S[3, 3]
case1_case3 -2
case2_case3 s[3, 4]
case3_case d[3, 3]
case3_case2 GcurrentForestCost - G(rG) 
Right (3, 3, 1, 2)
Save to S[3, 2]
case1_case3 -3
case2_case3 s[3, 3]
case3_case d[3, 2]
case3_case2 GcurrentForestCost - G(rG) 
Right (3, 3, 1, 1)
Save to S[3, 1]
case1_case3 -4
case2_case3 s[3, 2]
case3_case d[3, 4]
case3_case2 GcurrentForestCost - G(rG) 
D[2, 0] = S[3, 1]
Q[3] = S[3, 1]
T[1, 4] = S[3, 4]
T[1, 3] = S[3, 3]
T[1, 2] = S[3, 2]
T[1, 1] = S[3, 1]
new Round B'
updateFnArray(-1, 0, 0)
fn[0] = fn[6]
fn[6] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
endG_in_preR = 0
start from rG = 0
FN
1 2 3 4 -1 -1 
FT
-1 0 1 2 3 -1 
new Round C'
Right (3, 3, 0, 0)
Save to S[3, 0]
case3 = 0
case1_case3 = -5
case2_case2 = q[3]
case3_case3 D[3, 0]
T[0, 0] = S[3, 0]
new Round B'
updateFnArray(-1, 1, 0)
fn[1] = fn[6]
fn[6] = 1
updateFtArray(-1, 1)
ft[1] = -1
endG_in_preR = 0
start from rG = 1
FN
-1 -1 -1 -1 -1 -1 
FT
-1 -1 -1 -1 -1 -1 
new Round C'
Right (2, 2, 4, 1)
Save to S[2, 1]
case3 = 0
case1_case2 = t[4, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[2, 4]
T[4, 1] = S[2, 1]
new Round B'
updateFnArray(1, 3, 0)
fn[3] = fn[1]
fn[1] = 3
updateFtArray(1, 3)
ft[3] = 1
endG_in_preR = 0
start from rG = 3
FN
-1 3 -1 -1 -1 -1 
FT
-1 -1 -1 1 -1 -1 
new Round C'
Right (2, 2, 3, 3)
Save to S[2, 3]
case3 = 0
case1_case2 = t[3, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[2, 3]
Right (2, 2, 3, 1)
Save to S[2, 1]
case1_case2 t[3, 1]
case2_case3 s[2, 3]
case3_case d[2, 4]
case3_case2 GcurrentForestCost - G(rG) 
Q[2] = S[2, 3]
T[3, 3] = S[2, 3]
T[3, 1] = S[2, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1]
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 0
start from rG = 2
FN
-1 2 3 -1 -1 -1 
FT
-1 -1 1 2 -1 -1 
new Round C'
Right (2, 2, 2, 2)
Save to S[2, 2]
case3 = 0
case1_case2 = t[2, 2]
case2_case2 = q[2]
case3_case3 D[2, 2]
Right (2, 2, 2, 1)
Save to S[2, 1]
case1_case2 t[2, 1]
case2_case3 s[2, 2]
case3_case d[2, 4]
case3_case2 GcurrentForestCost - G(rG) 
T[2, 2] = S[2, 2]
T[2, 1] = S[2, 1]
new Round B'
updateFnArray(3, 4, 0)
fn[4] = fn[3]
fn[3] = 4
updateFtArray(3, 4)
ft[4] = 3
endG_in_preR = 0
start from rG = 4
FN
-1 2 3 4 -1 -1 
FT
-1 -1 1 2 3 -1 
new Round C'
Right (2, 2, 1, 4)
Save to S[2, 4]
case3 = 0
case1_case2 = t[1, 4]
case2_case1 = FcurrentForestCost
case3_case3 D[2, 1]
Right (2, 2, 1, 3)
Save to S[2, 3]
case1_case2 t[1, 3]
case2_case3 s[2, 4]
case3_case d[2, 3]
case3_case2 GcurrentForestCost - G(rG) 
Right (2, 2, 1, 2)
Save to S[2, 2]
case1_case2 t[1, 2]
case2_case3 s[2, 3]
case3_case d[2, 2]
case3_case2 GcurrentForestCost - G(rG) 
Right (2, 2, 1, 1)
Save to S[2, 1]
case1_case2 t[1, 1]
case2_case3 s[2, 2]
case3_case d[2, 4]
case3_case2 GcurrentForestCost - G(rG) 
Q[2] = S[2, 1]
T[1, 4] = S[2, 4]
T[1, 3] = S[2, 3]
T[1, 2] = S[2, 2]
T[1, 1] = S[2, 1]
new Round B'
updateFnArray(-1, 0, 0)
fn[0] = fn[6]
fn[6] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
endG_in_preR = 0
start from rG = 0
FN
1 2 3 4 -1 -1 
FT
-1 0 1 2 3 -1 
new Round C'
Right (2, 2, 0, 0)
Save to S[2, 0]
case3 = 0
case1_case2 = t[0, 0]
case2_case2 = q[2]
case3_case3 D[2, 0]
T[0, 0] = S[2, 0]
new Round B
fn[1] = fn[6]
fn[6] = 1
ft[1] = -1
ft[fn[1]] = 1
new round C
Left (1, 2, 1, 4)
Save to S[1, 1]
case3_case FcurrentForest - F(lF)
case1_case2 t[1, 4]
case2_case1 FcurrentForestCost
rGminus1_in_preR = 3 rG = 4 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[1, 4] = S[1, 1]
new Round B
fn[3] = fn[1]
fn[1] = 3
ft[3] = 1
ft[fn[3]] = 3
new round C
Left (1, 2, 3, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(lF)
case1_case2 t[3, 3]
case2_case1 FcurrentForestCost
Left (1, 2, 1, 3)
Save to S[1, 1]
case1_case2 t[1, 3]
case2 s[1, 3]
case3 d[1, 1]
case3 t[3, 3]
rGminus1_in_preR = 2 rG = 3 parent_of_rG_in_preL = 2 parent_of_rG_in_preR = 2
Q[1] = S[1, 3]
T[3, 3] = S[1, 3]
T[1, 3] = S[1, 1]
new Round B
fn[2] = fn[1]
fn[1] = 2
ft[2] = 1
ft[fn[2]] = 2
new round C
Left (1, 2, 2, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 2]
case2_case2 q[1]
Left (1, 2, 1, 2)
Save to S[1, 1]
case1_case2 t[1, 2]
case2 s[1, 2]
case3 d[1, 1]
case3 t[2, 2]
rGminus1_in_preR = 1 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
T[2, 2] = S[1, 2]
T[1, 2] = S[1, 1]
new Round B
fn[4] = fn[3]
fn[3] = 4
ft[4] = 3
ft[fn[4]] = 4
new round C
Left (1, 2, 4, 1)
Save to S[1, 4]
case3_case FcurrentForest - F(lF)
case1_case2 t[4, 1]
case2_case1 FcurrentForestCost
Left (1, 2, 3, 1)
Save to S[1, 3]
case1_case2 t[3, 1]
case2 s[1, 4]
case3 d[1, 3]
case3 t[4, 1]
Left (1, 2, 2, 1)
Save to S[1, 2]
case1_case2 t[2, 1]
case2 s[1, 3]
case3 d[1, 2]
case3 t[4, 1]
Left (1, 2, 1, 1)
Save to S[1, 1]
case1_case2 t[1, 1]
case2 s[1, 2]
case3 d[1, 1]
case3 t[2, 1]
rGminus1_in_preR = 0 rG = 1 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
Q[1] = S[1, 1]
T[4, 1] = S[1, 4]
T[3, 1] = S[1, 3]
T[2, 1] = S[1, 2]
T[1, 1] = S[1, 1]
new Round B
fn[0] = fn[6]
fn[6] = 0
ft[0] = -1
ft[fn[0]] = 0
new round C
Left (1, 2, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(lF)
case1_case2 t[0, 0]
case2_case2 q[1]
rGminus1_in_preR = 2147483647 rG = 0 parent_of_rG_in_preL = 2147483647 parent_of_rG_in_preR = 2147483647
T[0, 0] = S[1, 0]
new Round B'
updateFnArray(-1, 1, 0)
fn[1] = fn[6]
fn[6] = 1
updateFtArray(-1, 1)
ft[1] = -1
endG_in_preR = 0
start from rG = 1
FN
-1 -1 -1 -1 -1 -1 
FT
-1 -1 -1 -1 -1 -1 
new Round C'
Right (1, 1, 4, 1)
Save to S[1, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[4, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[4, 4]
new Round C'
Right (0, 0, 4, 1)
Save to S[0, 1]
case3 = 0
case1_case1 = s[1, 1]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 4]
T[4, 1] = S[0, 1]
new Round B'
updateFnArray(1, 3, 0)
fn[3] = fn[1]
fn[1] = 3
updateFtArray(1, 3)
ft[3] = 1
endG_in_preR = 0
start from rG = 3
FN
-1 3 -1 -1 -1 -1 
FT
-1 -1 -1 1 -1 -1 
new Round C'
Right (1, 1, 3, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[4, 3]
Right (1, 1, 3, 1)
Save to S[1, 1]
case1_case2 t[3, 1]
case2_case3 s[1, 3]
case3_case d[4, 4]
case3_case3 t[3, 3]
new Round C'
Right (0, 0, 3, 3)
Save to S[0, 3]
case3 = 0
case1_case1 = s[1, 3]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 3]
Right (0, 0, 3, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 3]
case3_case d[0, 4]
case3_case2 GcurrentForestCost - G(rG) 
D[0, 2] = S[0, 3]
Q[1] = S[1, 3]
Q[0] = S[0, 3]
T[3, 3] = S[0, 3]
T[3, 1] = S[0, 1]
new Round B'
updateFnArray(1, 2, 0)
fn[2] = fn[1]
fn[1] = 2
updateFtArray(1, 2)
ft[2] = 1
ft[fn[2]] = 2
endG_in_preR = 0
start from rG = 2
FN
-1 2 3 -1 -1 -1 
FT
-1 -1 1 2 -1 -1 
new Round C'
Right (1, 1, 2, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 2]
case2_case2 = q[1]
case3_case3 D[4, 2]
Right (1, 1, 2, 1)
Save to S[1, 1]
case1_case2 t[2, 1]
case2_case3 s[1, 2]
case3_case d[4, 4]
case3_case3 t[2, 2]
new Round C'
Right (0, 0, 2, 2)
Save to S[0, 2]
case3 = 0
case1_case1 = s[1, 2]
case2_case2 = q[0]
case3_case3 D[0, 2]
Right (0, 0, 2, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 2]
case3_case d[0, 4]
case3_case2 GcurrentForestCost - G(rG) 
T[2, 2] = S[0, 2]
T[2, 1] = S[0, 1]
new Round B'
updateFnArray(3, 4, 0)
fn[4] = fn[3]
fn[3] = 4
updateFtArray(3, 4)
ft[4] = 3
endG_in_preR = 0
start from rG = 4
FN
-1 2 3 4 -1 -1 
FT
-1 -1 1 2 3 -1 
new Round C'
Right (1, 1, 1, 4)
Save to S[1, 4]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 4]
case2_case1 = FcurrentForestCost
case3_case3 D[4, 1]
Right (1, 1, 1, 3)
Save to S[1, 3]
case1_case2 t[1, 3]
case2_case3 s[1, 4]
case3_case d[4, 3]
case3_case3 t[1, 4]
Right (1, 1, 1, 2)
Save to S[1, 2]
case1_case2 t[1, 2]
case2_case3 s[1, 3]
case3_case d[4, 2]
case3_case3 t[1, 4]
Right (1, 1, 1, 1)
Save to S[1, 1]
case1_case2 t[1, 1]
case2_case3 s[1, 2]
case3_case d[4, 4]
case3_case3 t[1, 2]
new Round C'
Right (0, 0, 1, 4)
Save to S[0, 4]
case3 = 0
case1_case1 = s[1, 4]
case2_case1 = FcurrentForestCost
case3_case3 D[0, 1]
Right (0, 0, 1, 3)
Save to S[0, 3]
case1_case1 s[1, 3]
case2_case3 s[0, 4]
case3_case d[0, 3]
case3_case2 GcurrentForestCost - G(rG) 
Right (0, 0, 1, 2)
Save to S[0, 2]
case1_case1 s[1, 2]
case2_case3 s[0, 3]
case3_case d[0, 2]
case3_case2 GcurrentForestCost - G(rG) 
Right (0, 0, 1, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 2]
case3_case d[0, 4]
case3_case2 GcurrentForestCost - G(rG) 
D[0, 0] = S[0, 1]
Q[1] = S[1, 1]
Q[0] = S[0, 1]
T[1, 4] = S[0, 4]
T[1, 3] = S[0, 3]
T[1, 2] = S[0, 2]
T[1, 1] = S[0, 1]
new Round B'
updateFnArray(-1, 0, 0)
fn[0] = fn[6]
fn[6] = 0
updateFtArray(-1, 0)
ft[0] = -1
ft[fn[0]] = 0
endG_in_preR = 0
start from rG = 0
FN
1 2 3 4 -1 -1 
FT
-1 0 1 2 3 -1 
new Round C'
Right (1, 1, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[1]
case3_case3 D[4, 0]
new Round C'
Right (0, 0, 0, 0)
Save to S[0, 0]
case3 = 0
case1_case1 = s[1, 0]
case2_case2 = q[0]
case3_case3 D[0, 0]
T[0, 0] = S[0, 0]
