Compute Free(1, 0)
If select 1 in Tree A #Subproblem: 5 Direction: Right
Compute Free(1, 1)
If select 1 in Tree A #Subproblem: 2 Direction: Left
Compute Free(1, 2)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 2)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(1, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(1, 1)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 3)
If select 1 in Tree A #Subproblem: 1 Direction: Left
Compute Free(1, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(1, 3)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(1, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(1, 0)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(3, 0)
If select 3 in Tree A #Subproblem: 5 Direction: Right
Compute Free(3, 1)
If select 3 in Tree A #Subproblem: 2 Direction: Left
Compute Free(3, 2)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(3, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(3, 1)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 3)
If select 3 in Tree A #Subproblem: 1 Direction: Left
Compute Free(3, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(3, 3)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(3, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(3, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(2, 2)
If select 2 in Tree B #Subproblem: 2 Direction: Left
Compute Free(2, 2)
If select 3(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(2, 2)
If select 3(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(2, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
Compute Free(2, 1)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
Compute Free(2, 1)
If select 3(rightmost) in Tree A #Subproblem: 4 Direction: Left
Compute Free(2, 1)
If select 2(leftmost) in Tree B #Subproblem: 4 Direction: Right
Compute Free(2, 1)
If select 2(rightmost) in Tree B #Subproblem: 4 Direction: Left
FreeS(2, 1)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(2, 3)
If select 3 in Tree B #Subproblem: 2 Direction: Left
Compute Free(2, 3)
If select 3(leftmost) in Tree A #Subproblem: 2 Direction: Right
Compute Free(2, 3)
If select 3(rightmost) in Tree A #Subproblem: 2 Direction: Left
FreeS(2, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
Compute Free(2, 0)
If select 3(leftmost) in Tree A #Subproblem: 10 Direction: Right
Compute Free(2, 0)
If select 3(rightmost) in Tree A #Subproblem: 12 Direction: Left
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 10 Direction: Right
Compute Free(2, 0)
If select 3(rightmost) in Tree B #Subproblem: 12 Direction: Left
FreeS(2, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(4, 0)
If select 4 in Tree A #Subproblem: 5 Direction: Right
Compute Free(4, 1)
If select 4 in Tree A #Subproblem: 2 Direction: Left
Compute Free(4, 2)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 2)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 1)
If select 2(leftmost) in Tree B #Subproblem: 2 Direction: Right
Compute Free(4, 1)
If select 2(rightmost) in Tree B #Subproblem: 2 Direction: Left
FreeS(4, 1)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 3)
If select 4 in Tree A #Subproblem: 1 Direction: Left
Compute Free(4, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Left
FreeS(4, 3)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 0)
If select 1(leftmost) in Tree B #Subproblem: 5 Direction: Right
Compute Free(4, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
FreeS(4, 0)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(0, 2)
If select 2 in Tree B #Subproblem: 8 Direction: Left
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 8 Direction: Right
Compute Free(0, 2)
If select 2 in Tree A #Subproblem: 7 Direction: Left
Compute Free(0, 2)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
FreeS(0, 2)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 16 Direction: Right
Compute Free(0, 1)
If select 2 in Tree A #Subproblem: 14 Direction: Left
Compute Free(0, 1)
If select 4(rightmost) in Tree A #Subproblem: 16 Direction: Left
Compute Free(0, 1)
If select 2(leftmost) in Tree B #Subproblem: 16 Direction: Right
Compute Free(0, 1)
If select 2(rightmost) in Tree B #Subproblem: 16 Direction: Left
FreeS(0, 1)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 3)
If select 3 in Tree B #Subproblem: 8 Direction: Left
Compute Free(0, 3)
If select 1(leftmost) in Tree A #Subproblem: 8 Direction: Right
Compute Free(0, 3)
If select 2 in Tree A #Subproblem: 7 Direction: Left
Compute Free(0, 3)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
FreeS(0, 3)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 40 Direction: Right
Compute Free(0, 0)
If select 2 in Tree A #Subproblem: 38 Direction: Right
Compute Free(0, 0)
If select 4(rightmost) in Tree A #Subproblem: 45 Direction: Left
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 39 Direction: Right
Compute Free(0, 0)
If select 3(rightmost) in Tree B #Subproblem: 46 Direction: Left
FreeS(0, 0)
Keynode: 2 in Tree A
Direction: rightLeaf: 3
RESULT
3 in A 3 in A 3 in A 3 in A 
1 in A 1 in A 1 in A 1 in A 
3 in A 3 in A 2 in B 3 in B 
3 in A 3 in A 3 in A 3 in A 
4 in A 4 in A 4 in A 4 in A 
gted(0, 0)
treeSizeA = 5
treeSizeB = 4
gted(0, 0) create problem in A gted(3, 0)
gted(3, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(1, 0)
gted(1, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
gted(0, 0) create problem in A gted(2, 0)
gted(2, 0)
treeSizeA = 2
treeSizeB = 4
gted(2, 0) create problem in A gted(3, 0)
gted(0, 0) create problem in A gted(4, 0)
gted(4, 0)
treeSizeA = 1
treeSizeB = 4
return 0.0f
new Round B'
new Round C'
Right (3, 3, 3, 1)
Save to S[3, 1]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
T[3, 1] = S[3, 1]
new Round B'
new Round C'
Right (3, 3, 2, 3)
Save to S[3, 3]
case3 = 0
case1_case3 = -1
case2_case1 = FcurrentForestCost
Right (3, 3, 2, 1)
Save to S[3, 1]
case1_case3 -2
case2_case3 s[3, 3]
case3_case d[3, 3]
D[2, 1] = S[3, 3]
Q[3] = S[3, 3]
T[2, 3] = S[3, 3]
T[2, 1] = S[3, 1]
new Round B'
new Round C'
Right (3, 3, 1, 2)
Save to S[3, 2]
case3 = 0
case1_case3 = -2
case2_case2 = q[3]
Right (3, 3, 1, 1)
Save to S[3, 1]
case1_case3 -3
case2_case3 s[3, 2]
case3_case d[3, 3]
D[2, 0] = S[3, 1]
Q[3] = S[3, 1]
T[1, 2] = S[3, 2]
T[1, 1] = S[3, 1]
new Round B'
new Round C'
Right (3, 3, 0, 0)
Save to S[3, 0]
case3 = 0
case1_case3 = -4
case2_case2 = q[3]
T[0, 0] = S[3, 0]
new Round B'
new Round C'
Right (2, 2, 3, 1)
Save to S[2, 1]
case3 = 0
case1_case2 = t[3, 1]
case2_case1 = FcurrentForestCost
T[3, 1] = S[2, 1]
new Round B'
new Round C'
Right (2, 2, 2, 3)
Save to S[2, 3]
case3 = 0
case1_case2 = t[2, 3]
case2_case1 = FcurrentForestCost
Right (2, 2, 2, 1)
Save to S[2, 1]
case1_case2 t[2, 1]
case2_case3 s[2, 3]
case3_case d[2, 3]
Q[2] = S[2, 3]
T[2, 3] = S[2, 3]
T[2, 1] = S[2, 1]
new Round B'
new Round C'
Right (2, 2, 1, 2)
Save to S[2, 2]
case3 = 0
case1_case2 = t[1, 2]
case2_case2 = q[2]
Right (2, 2, 1, 1)
Save to S[2, 1]
case1_case2 t[1, 1]
case2_case3 s[2, 2]
case3_case d[2, 3]
Q[2] = S[2, 1]
T[1, 2] = S[2, 2]
T[1, 1] = S[2, 1]
new Round B'
new Round C'
Right (2, 2, 0, 0)
Save to S[2, 0]
case3 = 0
case1_case2 = t[0, 0]
case2_case2 = q[2]
T[0, 0] = S[2, 0]
new Round B
new round C
Left (1, 2, 2, 3)
Save to S[1, 2]
case3_case FcurrentForest - F(lF)
case1_case2 t[2, 3]
case2_case1 FcurrentForestCost
T[2, 3] = S[1, 2]
new Round B
new round C
Left (1, 2, 1, 2)
Save to S[1, 1]
case3_case FcurrentForest - F(lF)
case1_case2 t[1, 2]
case2_case2 q[1]
T[1, 2] = S[1, 1]
new Round B
new round C
Left (1, 2, 3, 1)
Save to S[1, 3]
case3_case FcurrentForest - F(lF)
case1_case2 t[3, 1]
case2_case1 FcurrentForestCost
Left (1, 2, 2, 1)
Save to S[1, 2]
case1_case2 t[2, 1]
case2 s[1, 3]
case3 d[1, 2]
case3 t[3, 1]
Left (1, 2, 1, 1)
Save to S[1, 1]
case1_case2 t[1, 1]
case2 s[1, 2]
case3 d[1, 1]
case3 t[3, 1]
Q[1] = S[1, 1]
T[3, 1] = S[1, 3]
T[2, 1] = S[1, 2]
T[1, 1] = S[1, 1]
new Round B
new round C
Left (1, 2, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(lF)
case1_case2 t[0, 0]
case2_case2 q[1]
T[0, 0] = S[1, 0]
new Round B'
new Round C'
Right (1, 1, 3, 1)
Save to S[1, 1]
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 1]
case2_case1 = FcurrentForestCost
new Round C'
Right (0, 0, 3, 1)
Save to S[0, 1]
case3 = 0
case1_case1 = s[1, 1]
case2_case1 = FcurrentForestCost
T[3, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 1, 2, 3)
Save to S[1, 3]
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 3]
case2_case1 = FcurrentForestCost
Right (1, 1, 2, 1)
Save to S[1, 1]
case1_case2 t[2, 1]
case2_case3 s[1, 3]
case3_case d[4, 3]
new Round C'
Right (0, 0, 2, 3)
Save to S[0, 3]
case3 = 0
case1_case1 = s[1, 3]
case2_case1 = FcurrentForestCost
Right (0, 0, 2, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 3]
case3_case d[0, 3]
D[0, 1] = S[0, 3]
Q[1] = S[1, 3]
Q[0] = S[0, 3]
T[2, 3] = S[0, 3]
T[2, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 1, 1, 2)
Save to S[1, 2]
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 2]
case2_case2 = q[1]
Right (1, 1, 1, 1)
Save to S[1, 1]
case1_case2 t[1, 1]
case2_case3 s[1, 2]
case3_case d[4, 3]
new Round C'
Right (0, 0, 1, 2)
Save to S[0, 2]
case3 = 0
case1_case1 = s[1, 2]
case2_case2 = q[0]
Right (0, 0, 1, 1)
Save to S[0, 1]
case1_case1 s[1, 1]
case2_case3 s[0, 2]
case3_case d[0, 3]
D[0, 0] = S[0, 1]
Q[1] = S[1, 1]
Q[0] = S[0, 1]
T[1, 2] = S[0, 2]
T[1, 1] = S[0, 1]
new Round B'
new Round C'
Right (1, 1, 0, 0)
Save to S[1, 0]
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0]
case2_case2 = q[1]
new Round C'
Right (0, 0, 0, 0)
Save to S[0, 0]
case3 = 0
case1_case1 = s[1, 0]
case2_case2 = q[0]
T[0, 0] = S[0, 0]
