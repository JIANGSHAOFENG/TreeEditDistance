Compute Free(1, 0)
If select 1 in Tree A #Subproblem: 5 Direction: LeftCompute Free(1, 1)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[1][1] freeSumA = 0 freeSumB = 0
Free[1][1] = 1
FreeS(1, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(1, 2)
If select 1 in Tree A #Subproblem: 2 Direction: LeftCompute Free(1, 3)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[1][3] freeSumA = 0 freeSumB = 0
Free[1][3] = 1
FreeS(1, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[1][2] freeSumA = 0 freeSumB = 1
LeftB[1, 3] = 1
Compute Free(1, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
bleftmost = 2
RightB(1, 3) = 1
brightmost = 2
Compute Free(1, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
Free[1][2] = 2
FreeS(1, 2)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(1, 4)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Leftfree[1][4] freeSumA = 0 freeSumB = 0
Free[1][4] = 1
FreeS(1, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[1][0] freeSumA = 0 freeSumB = 4
LeftB[1, 1] = 1
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
bleftmost = 8
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -2 childrenSizeSumB[0] = 1
right = 3
Compute Free(1, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
RightB(1, 4) = 1
brightmost = 8
Compute Free(1, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
Free[1][0] = 5
FreeS(1, 0)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(3, 0)
If select 3 in Tree A #Subproblem: 5 Direction: LeftCompute Free(3, 1)
If select 3 in Tree A #Subproblem: 1 Direction: LeftCompute Free(3, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[3][1] freeSumA = 0 freeSumB = 0
Free[3][1] = 1
FreeS(3, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(3, 2)
If select 3 in Tree A #Subproblem: 2 Direction: LeftCompute Free(3, 3)
If select 3 in Tree A #Subproblem: 1 Direction: LeftCompute Free(3, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[3][3] freeSumA = 0 freeSumB = 0
Free[3][3] = 1
FreeS(3, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[3][2] freeSumA = 0 freeSumB = 1
LeftB[3, 3] = 1
Compute Free(3, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
bleftmost = 2
RightB(3, 3) = 1
brightmost = 2
Compute Free(3, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
Free[3][2] = 2
FreeS(3, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(3, 4)
If select 3 in Tree A #Subproblem: 1 Direction: LeftCompute Free(3, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Leftfree[3][4] freeSumA = 0 freeSumB = 0
Free[3][4] = 1
FreeS(3, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[3][0] freeSumA = 0 freeSumB = 4
LeftB[3, 1] = 1
Compute Free(3, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
bleftmost = 8
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -2 childrenSizeSumB[0] = 1
right = 3
Compute Free(3, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
RightB(3, 4) = 1
brightmost = 8
Compute Free(3, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
Free[3][0] = 5
FreeS(3, 0)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(4, 0)
If select 4 in Tree A #Subproblem: 5 Direction: LeftCompute Free(4, 1)
If select 4 in Tree A #Subproblem: 1 Direction: LeftCompute Free(4, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[4][1] freeSumA = 0 freeSumB = 0
Free[4][1] = 1
FreeS(4, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(4, 2)
If select 4 in Tree A #Subproblem: 2 Direction: LeftCompute Free(4, 3)
If select 4 in Tree A #Subproblem: 1 Direction: LeftCompute Free(4, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[4][3] freeSumA = 0 freeSumB = 0
Free[4][3] = 1
FreeS(4, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[4][2] freeSumA = 0 freeSumB = 1
LeftB[4, 3] = 1
Compute Free(4, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
bleftmost = 2
RightB(4, 3) = 1
brightmost = 2
Compute Free(4, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
Free[4][2] = 2
FreeS(4, 2)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(4, 4)
If select 4 in Tree A #Subproblem: 1 Direction: LeftCompute Free(4, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Leftfree[4][4] freeSumA = 0 freeSumB = 0
Free[4][4] = 1
FreeS(4, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[4][0] freeSumA = 0 freeSumB = 4
LeftB[4, 1] = 1
Compute Free(4, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
bleftmost = 8
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -2 childrenSizeSumB[0] = 1
right = 3
Compute Free(4, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
RightB(4, 4) = 1
brightmost = 8
Compute Free(4, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
Free[4][0] = 5
FreeS(4, 0)
Keynode: 4 in Tree A
Direction: rightLeaf: 4
Compute Free(2, 1)
If select 1 in Tree B #Subproblem: 3 Direction: Leftfree[2][1] freeSumA = 2 freeSumB = 0
LeftA[3, 1] = 1
Compute Free(2, 1)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(3, 1)(1) leftA(3, 1)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[4, 1] set to 4
arightmost = 4
Compute Free(2, 1)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[2][1] = 3
FreeS(2, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(2, 3)
If select 3 in Tree B #Subproblem: 3 Direction: Leftfree[2][3] freeSumA = 2 freeSumB = 0
LeftA[3, 3] = 1
Compute Free(2, 3)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(3, 3)(1) leftA(3, 3)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[4, 3] set to 4
arightmost = 4
Compute Free(2, 3)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[2][3] = 3
FreeS(2, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[2][2] freeSumA = 4 freeSumB = 3
LeftA[3, 2] = 2
Compute Free(2, 2)
If select 3(leftmost) in Tree A #Subproblem: 8 Direction: Right
free(3, 2)(2) leftA(3, 2)(2)  b->getLeftmostForestNum() = 2 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 8
RightA[4, 2] set to 4
arightmost = 8
Compute Free(2, 2)
If select 4(rightmost) in Tree A #Subproblem: 8 Direction: Left
LeftB[2, 3] = 4
Compute Free(2, 2)
If select 3(leftmost) in Tree B #Subproblem: 8 Direction: Right
bleftmost = 8
RightB(2, 3) = 4
brightmost = 8
Compute Free(2, 2)
If select 3(rightmost) in Tree B #Subproblem: 8 Direction: Left
Free[2][2] = 8
FreeS(2, 2)
Keynode: 3 in Tree A
Direction: rightLeaf: 3
Compute Free(2, 4)
If select 4 in Tree B #Subproblem: 3 Direction: Leftfree[2][4] freeSumA = 2 freeSumB = 0
LeftA[3, 4] = 1
Compute Free(2, 4)
If select 3(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(3, 4)(1) leftA(3, 4)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[4, 4] set to 4
arightmost = 4
Compute Free(2, 4)
If select 4(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[2][4] = 3
FreeS(2, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[2][0] freeSumA = 10 freeSumB = 14
LeftA[3, 0] = 8
Compute Free(2, 0)
If select 3(leftmost) in Tree A #Subproblem: 29 Direction: Right
free(3, 0)(5) leftA(3, 0)(8)  b->getLeftmostForestNum() = 8 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 29
RightA[4, 0] set to 4
arightmost = 29
Compute Free(2, 0)
If select 4(rightmost) in Tree A #Subproblem: 29 Direction: Left
LeftB[2, 1] = 4
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 31 Direction: Right
bleftmost = 31
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 12
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = 1 childrenSizeSumB[0] = 1
right = 12
Compute Free(2, 0)
If select 2 in Tree B #Subproblem: 26 Direction: Left
RightB(2, 4) = 4
brightmost = 31
Compute Free(2, 0)
If select 4(rightmost) in Tree B #Subproblem: 31 Direction: Left
Free[2][0] = 26
FreeS(2, 0)
Keynode: 2 in TreeB
Direction: left
Leaf: 3
Compute Free(5, 0)
If select 5 in Tree A #Subproblem: 5 Direction: LeftCompute Free(5, 1)
If select 5 in Tree A #Subproblem: 1 Direction: LeftCompute Free(5, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[5][1] freeSumA = 0 freeSumB = 0
Free[5][1] = 1
FreeS(5, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(5, 2)
If select 5 in Tree A #Subproblem: 2 Direction: LeftCompute Free(5, 3)
If select 5 in Tree A #Subproblem: 1 Direction: LeftCompute Free(5, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[5][3] freeSumA = 0 freeSumB = 0
Free[5][3] = 1
FreeS(5, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[5][2] freeSumA = 0 freeSumB = 1
LeftB[5, 3] = 1
Compute Free(5, 2)
If select 3(leftmost) in Tree B #Subproblem: 2 Direction: Right
bleftmost = 2
RightB(5, 3) = 1
brightmost = 2
Compute Free(5, 2)
If select 3(rightmost) in Tree B #Subproblem: 2 Direction: Left
Free[5][2] = 2
FreeS(5, 2)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(5, 4)
If select 5 in Tree A #Subproblem: 1 Direction: LeftCompute Free(5, 4)
If select 4 in Tree B #Subproblem: 1 Direction: Leftfree[5][4] freeSumA = 0 freeSumB = 0
Free[5][4] = 1
FreeS(5, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[5][0] freeSumA = 0 freeSumB = 4
LeftB[5, 1] = 1
Compute Free(5, 0)
If select 1(leftmost) in Tree B #Subproblem: 8 Direction: Right
bleftmost = 8
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -2 childrenSizeSumB[0] = 1
right = 3
Compute Free(5, 0)
If select 2 in Tree B #Subproblem: 7 Direction: Left
RightB(5, 4) = 1
brightmost = 8
Compute Free(5, 0)
If select 4(rightmost) in Tree B #Subproblem: 8 Direction: Left
Free[5][0] = 5
FreeS(5, 0)
Keynode: 5 in Tree A
Direction: rightLeaf: 5
Compute Free(0, 1)
If select 1 in Tree B #Subproblem: 6 Direction: Leftfree[0][1] freeSumA = 5 freeSumB = 0
LeftA[1, 1] = 1
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 10 Direction: Right
free(1, 1)(1) leftA(1, 1)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()5
aleftmost = 10
1 + childrenSizeSumA[1] = 2 childrenSizeSumA[2] - childrenSizeSumA[1] = 1
left = 3
1 + childrenSizeSumA[2] - childrenSizeSumA[1] = 2 childrenSizeSumA[0] = 1
right = 3
Compute Free(0, 1)
If select 2 in Tree A #Subproblem: 9 Direction: Left
RightA[5, 1] set to 5
arightmost = 10
Compute Free(0, 1)
If select 5(rightmost) in Tree A #Subproblem: 10 Direction: Left
Free[0][1] = 6
FreeS(0, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(0, 3)
If select 3 in Tree B #Subproblem: 6 Direction: Leftfree[0][3] freeSumA = 5 freeSumB = 0
LeftA[1, 3] = 1
Compute Free(0, 3)
If select 1(leftmost) in Tree A #Subproblem: 10 Direction: Right
free(1, 3)(1) leftA(1, 3)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()5
aleftmost = 10
1 + childrenSizeSumA[1] = 2 childrenSizeSumA[2] - childrenSizeSumA[1] = 1
left = 3
1 + childrenSizeSumA[2] - childrenSizeSumA[1] = 2 childrenSizeSumA[0] = 1
right = 3
Compute Free(0, 3)
If select 2 in Tree A #Subproblem: 9 Direction: Left
RightA[5, 3] set to 5
arightmost = 10
Compute Free(0, 3)
If select 5(rightmost) in Tree A #Subproblem: 10 Direction: Left
Free[0][3] = 6
FreeS(0, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[0][2] freeSumA = 12 freeSumB = 6
LeftA[1, 2] = 2
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 22 Direction: Right
free(1, 2)(2) leftA(1, 2)(2)  b->getLeftmostForestNum() = 2 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()5
aleftmost = 22
1 + childrenSizeSumA[1] = 2 childrenSizeSumA[2] - childrenSizeSumA[1] = 1
left = 6
1 + childrenSizeSumA[2] - childrenSizeSumA[1] = 2 childrenSizeSumA[0] = 1
right = 6
Compute Free(0, 2)
If select 2 in Tree A #Subproblem: 18 Direction: Left
RightA[5, 2] set to 5
arightmost = 22
Compute Free(0, 2)
If select 5(rightmost) in Tree A #Subproblem: 22 Direction: Left
LeftB[0, 3] = 11
Compute Free(0, 2)
If select 3(leftmost) in Tree B #Subproblem: 22 Direction: Right
bleftmost = 22
RightB(0, 3) = 11
brightmost = 22
Compute Free(0, 2)
If select 3(rightmost) in Tree B #Subproblem: 22 Direction: Left
Free[0][2] = 18
FreeS(0, 2)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
Compute Free(0, 4)
If select 4 in Tree B #Subproblem: 6 Direction: Leftfree[0][4] freeSumA = 5 freeSumB = 0
LeftA[1, 4] = 1
Compute Free(0, 4)
If select 1(leftmost) in Tree A #Subproblem: 10 Direction: Right
free(1, 4)(1) leftA(1, 4)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()5
aleftmost = 10
1 + childrenSizeSumA[1] = 2 childrenSizeSumA[2] - childrenSizeSumA[1] = 1
left = 3
1 + childrenSizeSumA[2] - childrenSizeSumA[1] = 2 childrenSizeSumA[0] = 1
right = 3
Compute Free(0, 4)
If select 2 in Tree A #Subproblem: 9 Direction: Left
RightA[5, 4] set to 5
arightmost = 10
Compute Free(0, 4)
If select 5(rightmost) in Tree A #Subproblem: 10 Direction: Left
Free[0][4] = 6
FreeS(0, 4)
Keynode: 4 in TreeB
Direction: rightLeaf: 4
free[0][0] freeSumA = 36 freeSumB = 30
LeftA[1, 0] = 8
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 79 Direction: Right
free(1, 0)(5) leftA(1, 0)(8)  b->getLeftmostForestNum() = 8 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()5
aleftmost = 79
1 + childrenSizeSumA[1] = 2 childrenSizeSumA[2] - childrenSizeSumA[1] = 1
left = 26
1 + childrenSizeSumA[2] - childrenSizeSumA[1] = 2 childrenSizeSumA[0] = 1
right = 26
Compute Free(0, 0)
If select 2 in Tree A #Subproblem: 71 Direction: Left
RightA[5, 0] set to 5
arightmost = 79
Compute Free(0, 0)
If select 5(rightmost) in Tree A #Subproblem: 79 Direction: Left
LeftB[0, 1] = 11
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 79 Direction: Right
bleftmost = 79
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 36
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = 2 childrenSizeSumB[0] = 1
right = 36
Compute Free(0, 0)
If select 2 in Tree B #Subproblem: 76 Direction: Left
RightB(0, 4) = 11
brightmost = 79
Compute Free(0, 0)
If select 4(rightmost) in Tree B #Subproblem: 79 Direction: Left
Free[0][0] = 71
FreeS(0, 0)
Keynode: 2 in Tree A
Direction: left
Leaf: 3
RESULT
3 in A 1 in B 3 in A 3 in B 4 in B 
1 in A 1 in B 1 in A 3 in B 4 in B 
3 in B 1 in B 3 in A 3 in B 4 in B 
3 in A 1 in B 3 in A 3 in B 4 in B 
4 in A 1 in B 4 in A 3 in B 4 in B 
5 in A 1 in B 5 in A 3 in B 4 in B 
Free
71 6 18 6 6 
5 1 2 1 1 
26 3 8 3 3 
5 1 2 1 1 
5 1 2 1 1 
5 1 2 1 1 

LeftA
-1 -1 -1 -1 -1 
8 1 2 1 1 
-1 -1 -1 -1 -1 
8 1 2 1 1 
-1 -1 -1 -1 -1 
-1 -1 -1 -1 -1 

RightA
-1 -1 -1 -1 -1 
-1 -1 -1 -1 -1 
-1 -1 -1 -1 -1 
-1 -1 -1 -1 -1 
8 1 2 1 1 
8 1 2 1 1 

AllA
-1 -1 -1 -1 -1 
-1 -1 -1 -1 -1 
35 4 8 4 4 
10 1 2 1 1 
10 1 2 1 1 
-1 -1 -1 -1 -1 

LeftB
-1 11 -1 11 -1 
-1 1 -1 1 -1 
-1 4 -1 4 -1 
-1 1 -1 1 -1 
-1 1 -1 1 -1 
-1 1 -1 1 -1 

RightB
-1 -1 -1 11 11 
-1 -1 -1 1 1 
-1 -1 -1 4 4 
-1 -1 -1 1 1 
-1 -1 -1 1 1 
-1 -1 -1 1 1 

AllB
-1 -1 28 14 -1 
-1 -1 2 1 -1 
-1 -1 8 4 -1 
-1 -1 2 1 -1 
-1 -1 2 1 -1 
-1 -1 2 1 -1 

gted(0, 0)
hasVisited[0, 0] = 0
treeSizeA = 6
treeSizeB = 5
getPathType A(0 ,3) = 2
A child = 3 currentPathNode = 3 parent = 2
A child = 4 currentPathNode = 3 parent = 2
gted(0, 0) create problem in A gted(4, 0)
gted(4, 0)
hasVisited[4, 0] = 0
treeSizeA = 1
treeSizeB = 5
cost = 5.000000
change F -> A from insert A nodeRenMinusIns = 0.000000
change F -> B from insert B nodeRenMinusIns = 0.000000
change F -> C from insert C nodeRenMinusIns = 0.000000
change F -> E from insert E nodeRenMinusIns = 0.000000
change F -> D from insert D nodeRenMinusIns = 0.000000
spf1(4, 0) = 5
A child = 1 currentPathNode = 2 parent = 0
gted(0, 0) create problem in A gted(1, 0)
gted(1, 0)
hasVisited[1, 0] = 0
treeSizeA = 1
treeSizeB = 5
cost = 5.000000
change B -> A from insert A nodeRenMinusIns = 0.000000
change B -> B from insert B nodeRenMinusIns = -1.000000
change B -> C from insert C nodeRenMinusIns = 0.000000
change B -> E from insert E nodeRenMinusIns = 0.000000
change B -> D from insert D nodeRenMinusIns = 0.000000
spf1(1, 0) = 4
A child = 2 currentPathNode = 2 parent = 0
A child = 5 currentPathNode = 2 parent = 0
gted(0, 0) create problem in A gted(5, 0)
gted(5, 0)
hasVisited[5, 0] = 0
treeSizeA = 1
treeSizeB = 5
cost = 5.000000
change D -> A from insert A nodeRenMinusIns = 0.000000
change D -> B from insert B nodeRenMinusIns = 0.000000
change D -> C from insert C nodeRenMinusIns = 0.000000
change D -> E from insert E nodeRenMinusIns = 0.000000
change D -> D from insert D nodeRenMinusIns = -1.000000
spf1(5, 0) = 4
swap = false pathType = 2
spfA_LR(0, 0) 0 
new Round B'
new Round C'
Right (3, 4, 4, 1) counter  = 16
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert D
case3_case3 delta[3, 4] = 0.000000
case3_case3 += E -> D = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
Save to s[4, 1] = 1.000000
t[4, 1] = s[4, 1] = 1.000000
new Round B'
new Round C'
Right (3, 4, 3, 3) counter  = 17
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert E
case3_case3 delta[3, 3] = 0.000000
case3_case3 += E -> E = 0.000000
case1 = 2.000000
case2 = 2.000000
case3 = 0.000000
Save to s[4, 3] = 0.000000
Right (3, 4, 3, 1) counter = 18
Save to s[4, 1]
case1_case3 GcurrentForestCost = 2 + delete F
case2_case3 s[4, 3] = 0.000000 + insert D
case3_case delta[3, 4] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 2.000000 - 1
case1 = 3.000000
case2 = 1.000000
case3 = 1.000000
s[4, 1] = 1.000000
q[4] = s[4, 3] = 0.000000
t[3, 3] = s[4, 3] = 0.000000
t[3, 1] = s[4, 1] = 1.000000
new Round B'
new Round C'
Right (3, 4, 2, 2) counter  = 19
case3 = 0
case1_case3 = GcurrentForestCost = 2
case1 += delete F
case2_case2 = q[4] = 0.000000
case2 += insert C
case3_case3 delta[3, 2] = 1.000000
case1 = 3.000000
case2 = 1.000000
case3 = 1.000000
Save to s[4, 2] = 1.000000
Right (3, 4, 2, 1) counter = 20
Save to s[4, 1]
case1_case3 GcurrentForestCost = 3 + delete F
case2_case3 s[4, 2] = 1.000000 + insert D
case3_case delta[3, 4] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 3.000000 - 1
case1 = 4.000000
case2 = 2.000000
case3 = 2.000000
s[4, 1] = 2.000000
t[2, 2] = s[4, 2] = 1.000000
t[2, 1] = s[4, 1] = 2.000000
new Round B'
new Round C'
Right (3, 4, 1, 4) counter  = 21
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert B
case3_case3 delta[3, 1] = 0.000000
case3_case3 += E -> B = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
Save to s[4, 4] = 1.000000
Right (3, 4, 1, 3) counter = 22
Save to s[4, 3]
case1_case3 GcurrentForestCost = 2 + delete F
case2_case3 s[4, 4] = 1.000000 + insert E
case3_case delta[3, 3] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 2.000000 - 1
case3 += E -> E
case1 = 3.000000
case2 = 2.000000
case3 = 1.000000
s[4, 3] = 1.000000
Right (3, 4, 1, 2) counter = 23
Save to s[4, 2]
case1_case3 GcurrentForestCost = 3 + delete F
case2_case3 s[4, 3] = 1.000000 + insert C
case3_case delta[3, 2] = 1.000000
case3_case2 += GcurrentForestCost - G(rG) = 3.000000 - 2
case1 = 4.000000
case2 = 2.000000
case3 = 2.000000
s[4, 2] = 2.000000
Right (3, 4, 1, 1) counter = 24
Save to s[4, 1]
case1_case3 GcurrentForestCost = 4 + delete F
case2_case3 s[4, 2] = 2.000000 + insert D
case3_case delta[3, 4] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 4.000000 - 1
case1 = 5.000000
case2 = 3.000000
case3 = 3.000000
s[4, 1] = 3.000000
q[4] = s[4, 1] = 3.000000
t[1, 4] = s[4, 4] = 1.000000
t[1, 3] = s[4, 3] = 1.000000
t[1, 2] = s[4, 2] = 2.000000
t[1, 1] = s[4, 1] = 3.000000
new Round B'
new Round C'
Right (3, 4, 0, 0) counter  = 25
case3 = 0
case1_case3 = GcurrentForestCost = 5
case1 += delete F
case2_case2 = q[4] = 3.000000
case2 += insert A
case3_case3 delta[3, 0] = 4.000000
case1 = 6.000000
case2 = 4.000000
case3 = 4.000000
Save to s[4, 0] = 4.000000
t[0, 0] = s[4, 0] = 4.000000
new Round B'
new Round C'
Right (3, 3, 4, 1) counter  = 26
case3_case FcurrentForest - F(rF)
case1_case2 = t[4, 1] = 1.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert D
case3_case3 delta[4, 4] = 0.000000
case3_case3 += F -> D = 1.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
Save to s[3, 1] = 2.000000
new Round C'
Right (2, 2, 4, 1) counter  = 27
case3 = 0
case1_case1 = s[3, 1] = 2.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert D
case3_case3 delta[2, 4] = 2.000000
case3_case3 += C -> D = 1.000000
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
Save to s[2, 1] = 3.000000
t[4, 1] = s[2, 1] = 3.000000
new Round B'
new Round C'
Right (3, 3, 3, 3) counter  = 28
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 3] = 0.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert E
case1 = 1.000000
case2 = 3.000000
case3 = 1.000000
Save to s[3, 3] = 1.000000
Right (3, 3, 3, 1) counter = 29
Save to s[3, 1]
case1_case2 t[3, 1] = 1.000000 + delete E
case2_case3 s[3, 3] = 1.000000 + insert D
case3_case delta[4, 4] = 0.000000
case3_case3 += t[3, 3] = 0.000000
case3 += F -> D
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
s[3, 1] = 1.000000
new Round C'
Right (2, 2, 3, 3) counter  = 30
case3 = 0
case1_case1 = s[3, 3] = 1.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert E
case3_case3 delta[2, 3] = 2.000000
case1 = 2.000000
case2 = 4.000000
case3 = 2.000000
Save to s[2, 3] = 2.000000
Right (2, 2, 3, 1) counter = 31
Save to s[2, 1]
case1_case1 s[3, 1] = 1.000000 + delete C
case2_case3 s[2, 3] = 2.000000 + insert D
case3_case delta[2, 4] = 2.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
s[2, 1] = 2.000000
save to delta[2, 2] = s[2, 3] = 1.000000
q[3] = s[3, 3] = 1.000000
q[2] = s[2, 3] = 2.000000
t[3, 3] = s[2, 3] = 2.000000
t[3, 1] = s[2, 1] = 2.000000
new Round B'
new Round C'
Right (3, 3, 2, 2) counter  = 32
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 2] = 1.000000
case1 += delete E
case2_case2 = q[3] = 1.000000
case2 += insert C
case3_case3 delta[4, 2] = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 2.000000
Save to s[3, 2] = 2.000000
Right (3, 3, 2, 1) counter = 33
Save to s[3, 1]
case1_case2 t[2, 1] = 2.000000 + delete E
case2_case3 s[3, 2] = 2.000000 + insert D
case3_case delta[4, 4] = 0.000000
case3_case3 += t[2, 2] = 1.000000
case3 += F -> D
case1 = 3.000000
case2 = 3.000000
case3 = 2.000000
s[3, 1] = 2.000000
new Round C'
Right (2, 2, 2, 2) counter  = 34
case3 = 0
case1_case1 = s[3, 2] = 2.000000
case1 += delete C
case2_case2 = q[2] = 2.000000
case2 += insert C
case3_case3 delta[2, 2] = 1.000000
case3_case3 += C -> C = 0.000000
case1 = 3.000000
case2 = 3.000000
case3 = 1.000000
Save to s[2, 2] = 1.000000
Right (2, 2, 2, 1) counter = 35
Save to s[2, 1]
case1_case1 s[3, 1] = 2.000000 + delete C
case2_case3 s[2, 2] = 1.000000 + insert D
case3_case delta[2, 4] = 2.000000
case1 = 3.000000
case2 = 2.000000
case3 = 2.000000
s[2, 1] = 2.000000
t[2, 2] = s[2, 2] = 1.000000
t[2, 1] = s[2, 1] = 2.000000
new Round B'
new Round C'
Right (3, 3, 1, 4) counter  = 36
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 4] = 1.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert B
case3_case3 delta[4, 1] = 0.000000
case3_case3 += F -> B = 1.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
Save to s[3, 4] = 2.000000
Right (3, 3, 1, 3) counter = 37
Save to s[3, 3]
case1_case2 t[1, 3] = 1.000000 + delete E
case2_case3 s[3, 4] = 2.000000 + insert E
case3_case delta[4, 3] = 0.000000
case3_case3 += t[1, 4] = 1.000000
case3 += F -> E
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
s[3, 3] = 2.000000
Right (3, 3, 1, 2) counter = 38
Save to s[3, 2]
case1_case2 t[1, 2] = 2.000000 + delete E
case2_case3 s[3, 3] = 2.000000 + insert C
case3_case delta[4, 2] = 1.000000
case3_case3 += t[1, 4] = 1.000000
case3 += F -> C
case1 = 3.000000
case2 = 3.000000
case3 = 3.000000
s[3, 2] = 3.000000
Right (3, 3, 1, 1) counter = 39
Save to s[3, 1]
case1_case2 t[1, 1] = 3.000000 + delete E
case2_case3 s[3, 2] = 3.000000 + insert D
case3_case delta[4, 4] = 0.000000
case3_case3 += t[1, 2] = 2.000000
case3 += F -> D
case1 = 4.000000
case2 = 4.000000
case3 = 3.000000
s[3, 1] = 3.000000
new Round C'
Right (2, 2, 1, 4) counter  = 40
case3 = 0
case1_case1 = s[3, 4] = 2.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert B
case3_case3 delta[2, 1] = 2.000000
case3_case3 += C -> B = 1.000000
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
Save to s[2, 4] = 3.000000
Right (2, 2, 1, 3) counter = 41
Save to s[2, 3]
case1_case1 s[3, 3] = 2.000000 + delete C
case2_case3 s[2, 4] = 3.000000 + insert E
case3_case delta[2, 3] = 2.000000
case3_case2 += GcurrentForestCost - G(rG) = 2.000000 - 1
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
s[2, 3] = 3.000000
Right (2, 2, 1, 2) counter = 42
Save to s[2, 2]
case1_case1 s[3, 2] = 3.000000 + delete C
case2_case3 s[2, 3] = 3.000000 + insert C
case3_case delta[2, 2] = 1.000000
case3_case2 += GcurrentForestCost - G(rG) = 3.000000 - 2
case3 += C -> C
case1 = 4.000000
case2 = 4.000000
case3 = 2.000000
s[2, 2] = 2.000000
Right (2, 2, 1, 1) counter = 43
Save to s[2, 1]
case1_case1 s[3, 1] = 3.000000 + delete C
case2_case3 s[2, 2] = 2.000000 + insert D
case3_case delta[2, 4] = 2.000000
case3_case2 += GcurrentForestCost - G(rG) = 4.000000 - 1
case1 = 4.000000
case2 = 3.000000
case3 = 5.000000
s[2, 1] = 3.000000
save to delta[2, 0] = s[2, 1] = 3.000000
q[3] = s[3, 1] = 3.000000
q[2] = s[2, 1] = 3.000000
t[1, 4] = s[2, 4] = 3.000000
t[1, 3] = s[2, 3] = 3.000000
t[1, 2] = s[2, 2] = 2.000000
t[1, 1] = s[2, 1] = 3.000000
new Round B'
new Round C'
Right (3, 3, 0, 0) counter  = 44
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0] = 4.000000
case1 += delete E
case2_case2 = q[3] = 3.000000
case2 += insert A
case3_case3 delta[4, 0] = 4.000000
case1 = 5.000000
case2 = 4.000000
case3 = 5.000000
Save to s[3, 0] = 4.000000
new Round C'
Right (2, 2, 0, 0) counter  = 45
case3 = 0
case1_case1 = s[3, 0] = 4.000000
case1 += delete C
case2_case2 = q[2] = 3.000000
case2 += insert A
case3_case3 delta[2, 0] = 3.000000
case3_case3 += C -> A = 1.000000
case1 = 5.000000
case2 = 4.000000
case3 = 4.000000
Save to s[2, 0] = 4.000000
t[0, 0] = s[2, 0] = 4.000000
new Round B
new round C hasLeftPart = 1
Left (1, 2, 1, 4) counter = 46
Save to s[1, 1]
case3_case FcurrentForest - F(lF) = 
4.000000 - 1
case1_case2 t[1, 4] = 3.000000
case2_case1 FcurrentForestCost = 4.000000
case3_case3 delta[1, 1] = 0.000000
case3 += B -> B
s[1, 1] = 3.000000
rGminus1_in_preR = 3 rG = 4 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
t[1, 4] = s[1, 1]
new Round B
new round C hasLeftPart = 1
Left (1, 2, 3, 3) counter = 47
Save to s[1, 3]
case3_case FcurrentForest - F(lF) = 
4.000000 - 1
case1_case2 t[3, 3] = 2.000000
case2_case1 FcurrentForestCost = 4.000000
s[1, 3] = 3.000000
Left (1, 2, 1, 3) counter = 48
Save to s[1, 1]
case1_case2 t[1, 3] = 3.000000 + delete B
case2 s[1, 3] = 3.000000 + insert B
case3 = delta[1, 1] = 0.000000
case3 += t[3, 3] = 2.000000
case3 += B -> B
s[1, 1] = 2.000000
rGminus1_in_preR = 2 rG = 3 parent_of_rG_in_preL = 2 parent_of_rG_in_preR = 2
q[1] = s[1, 3]
t[3, 3] = s[1, 3]
t[1, 3] = s[1, 1]
new Round B
new round C hasLeftPart = 1
Left (1, 2, 2, 2) counter = 49
Save to s[1, 2]
case3_case FcurrentForest - F(lF) = 
4.000000 - 1
case1_case2 t[2, 2] = 1.000000
case2_case2 q[1] = 3.000000
s[1, 2] = 2.000000
Left (1, 2, 1, 2) counter = 50
Save to s[1, 1]
case1_case2 t[1, 2] = 2.000000 + delete B
case2 s[1, 2] = 2.000000 + insert B
case3 = delta[1, 1] = 0.000000
case3 += t[2, 2] = 1.000000
case3 += B -> B
s[1, 1] = 1.000000
rGminus1_in_preR = 1 rG = 2 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
t[2, 2] = s[1, 2]
t[1, 2] = s[1, 1]
new Round B
new round C hasLeftPart = 1
Left (1, 2, 4, 1) counter = 51
Save to s[1, 4]
case3_case FcurrentForest - F(lF) = 
4.000000 - 1
case1_case2 t[4, 1] = 3.000000
case2_case1 FcurrentForestCost = 4.000000
case3_case3 delta[1, 4] = 0.000000
case3 += B -> D
s[1, 4] = 4.000000
Left (1, 2, 3, 1) counter = 52
Save to s[1, 3]
case1_case2 t[3, 1] = 2.000000 + delete B
case2 s[1, 4] = 4.000000 + insert E
case3 = delta[1, 3] = 0.000000
case3 += t[4, 1] = 3.000000
s[1, 3] = 3.000000
Left (1, 2, 2, 1) counter = 53
Save to s[1, 2]
case1_case2 t[2, 1] = 2.000000 + delete B
case2 s[1, 3] = 3.000000 + insert C
case3 = delta[1, 2] = 1.000000
case3 += t[4, 1] = 3.000000
s[1, 2] = 3.000000
Left (1, 2, 1, 1) counter = 54
Save to s[1, 1]
case1_case2 t[1, 1] = 3.000000 + delete B
case2 s[1, 2] = 3.000000 + insert B
case3 = delta[1, 1] = 0.000000
case3 += t[2, 1] = 2.000000
case3 += B -> B
s[1, 1] = 2.000000
rGminus1_in_preR = 0 rG = 1 parent_of_rG_in_preL = 0 parent_of_rG_in_preR = 0
q[1] = s[1, 1]
t[4, 1] = s[1, 4]
t[3, 1] = s[1, 3]
t[2, 1] = s[1, 2]
t[1, 1] = s[1, 1]
new Round B
new round C hasLeftPart = 1
Left (1, 2, 0, 0) counter = 55
Save to s[1, 0]
case3_case FcurrentForest - F(lF) = 
4.000000 - 1
case1_case2 t[0, 0] = 4.000000
case2_case2 q[1] = 2.000000
s[1, 0] = 2.000000
rGminus1_in_preR = 2147483647 rG = 0 parent_of_rG_in_preL = 2147483647 parent_of_rG_in_preR = 2147483647
t[0, 0] = s[1, 0]
new Round B'
new Round C'
Right (2, 1, 4, 1) counter  = 56
case3_case FcurrentForest - F(rF)
case1_case2 = t[4, 1] = 4.000000
case1 += delete B
case2_case1 = 5.000000
case2 += insert D
case3_case3 delta[5, 4] = 0.000000
case3_case3 += D -> D = 0.000000
case1 = 5.000000
case2 = 6.000000
case3 = 4.000000
Save to s[1, 1] = 4.000000
new Round C'
Right (0, 0, 4, 1) counter  = 57
case3 = 0
case1_case1 = s[1, 1] = 4.000000
case1 += delete A
case2_case1 = 6.000000
case2 += insert D
case3_case3 delta[0, 4] = 5.000000
case1 = 5.000000
case2 = 7.000000
case3 = 5.000000
Save to s[0, 1] = 5.000000
t[4, 1] = s[0, 1] = 5.000000
new Round B'
new Round C'
Right (2, 1, 3, 3) counter  = 58
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 3] = 3.000000
case1 += delete B
case2_case1 = 5.000000
case2 += insert E
case1 = 4.000000
case2 = 6.000000
case3 = 4.000000
Save to s[1, 3] = 4.000000
Right (2, 1, 3, 1) counter = 59
Save to s[1, 1]
case1_case2 t[3, 1] = 3.000000 + delete B
case2_case3 s[1, 3] = 4.000000 + insert D
case3_case delta[5, 4] = 0.000000
case3_case3 += t[3, 3] = 3.000000
case3 += D -> D
case1 = 4.000000
case2 = 5.000000
case3 = 3.000000
s[1, 1] = 3.000000
new Round C'
Right (0, 0, 3, 3) counter  = 60
case3 = 0
case1_case1 = s[1, 3] = 4.000000
case1 += delete A
case2_case1 = 6.000000
case2 += insert E
case3_case3 delta[0, 3] = 5.000000
case1 = 5.000000
case2 = 7.000000
case3 = 5.000000
Save to s[0, 3] = 5.000000
Right (0, 0, 3, 1) counter = 61
Save to s[0, 1]
case1_case1 s[1, 1] = 3.000000 + delete A
case2_case3 s[0, 3] = 5.000000 + insert D
case3_case delta[0, 4] = 5.000000
case1 = 4.000000
case2 = 6.000000
case3 = 5.000000
s[0, 1] = 4.000000
save to delta[0, 2] = s[0, 3] = 4.000000
q[1] = s[1, 3] = 4.000000
q[0] = s[0, 3] = 5.000000
t[3, 3] = s[0, 3] = 5.000000
t[3, 1] = s[0, 1] = 4.000000
new Round B'
new Round C'
Right (2, 1, 2, 2) counter  = 62
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 2] = 2.000000
case1 += delete B
case2_case2 = q[1] = 4.000000
case2 += insert C
case1 = 3.000000
case2 = 5.000000
case3 = 4.000000
Save to s[1, 2] = 3.000000
Right (2, 1, 2, 1) counter = 63
Save to s[1, 1]
case1_case2 t[2, 1] = 3.000000 + delete B
case2_case3 s[1, 2] = 3.000000 + insert D
case3_case delta[5, 4] = 0.000000
case3_case3 += t[2, 2] = 2.000000
case3 += D -> D
case1 = 4.000000
case2 = 4.000000
case3 = 2.000000
s[1, 1] = 2.000000
new Round C'
Right (0, 0, 2, 2) counter  = 64
case3 = 0
case1_case1 = s[1, 2] = 3.000000
case1 += delete A
case2_case2 = q[0] = 5.000000
case2 += insert C
case3_case3 delta[0, 2] = 4.000000
case1 = 4.000000
case2 = 6.000000
case3 = 4.000000
Save to s[0, 2] = 4.000000
Right (0, 0, 2, 1) counter = 65
Save to s[0, 1]
case1_case1 s[1, 1] = 2.000000 + delete A
case2_case3 s[0, 2] = 4.000000 + insert D
case3_case delta[0, 4] = 5.000000
case1 = 3.000000
case2 = 5.000000
case3 = 5.000000
s[0, 1] = 3.000000
t[2, 2] = s[0, 2] = 4.000000
t[2, 1] = s[0, 1] = 3.000000
new Round B'
new Round C'
Right (2, 1, 1, 4) counter  = 66
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 4] = 3.000000
case1 += delete B
case2_case1 = 5.000000
case2 += insert B
case1 = 4.000000
case2 = 6.000000
case3 = 4.000000
Save to s[1, 4] = 4.000000
Right (2, 1, 1, 3) counter = 67
Save to s[1, 3]
case1_case2 t[1, 3] = 2.000000 + delete B
case2_case3 s[1, 4] = 4.000000 + insert E
case3_case delta[5, 3] = 0.000000
case3_case3 += t[1, 4] = 3.000000
case1 = 3.000000
case2 = 5.000000
case3 = 3.000000
s[1, 3] = 3.000000
Right (2, 1, 1, 2) counter = 68
Save to s[1, 2]
case1_case2 t[1, 2] = 1.000000 + delete B
case2_case3 s[1, 3] = 3.000000 + insert C
case3_case delta[5, 2] = 1.000000
case3_case3 += t[1, 4] = 3.000000
case1 = 2.000000
case2 = 4.000000
case3 = 4.000000
s[1, 2] = 2.000000
Right (2, 1, 1, 1) counter = 69
Save to s[1, 1]
case1_case2 t[1, 1] = 2.000000 + delete B
case2_case3 s[1, 2] = 2.000000 + insert D
case3_case delta[5, 4] = 0.000000
case3_case3 += t[1, 2] = 1.000000
case3 += D -> D
case1 = 3.000000
case2 = 3.000000
case3 = 1.000000
s[1, 1] = 1.000000
new Round C'
Right (0, 0, 1, 4) counter  = 70
case3 = 0
case1_case1 = s[1, 4] = 4.000000
case1 += delete A
case2_case1 = 6.000000
case2 += insert B
case3_case3 delta[0, 1] = 5.000000
case1 = 5.000000
case2 = 7.000000
case3 = 5.000000
Save to s[0, 4] = 5.000000
Right (0, 0, 1, 3) counter = 71
Save to s[0, 3]
case1_case1 s[1, 3] = 3.000000 + delete A
case2_case3 s[0, 4] = 5.000000 + insert E
case3_case delta[0, 3] = 5.000000
case1 = 4.000000
case2 = 6.000000
case3 = 5.000000
s[0, 3] = 4.000000
Right (0, 0, 1, 2) counter = 72
Save to s[0, 2]
case1_case1 s[1, 2] = 2.000000 + delete A
case2_case3 s[0, 3] = 4.000000 + insert C
case3_case delta[0, 2] = 4.000000
case1 = 3.000000
case2 = 5.000000
case3 = 4.000000
s[0, 2] = 3.000000
Right (0, 0, 1, 1) counter = 73
Save to s[0, 1]
case1_case1 s[1, 1] = 1.000000 + delete A
case2_case3 s[0, 2] = 3.000000 + insert D
case3_case delta[0, 4] = 5.000000
case1 = 2.000000
case2 = 4.000000
case3 = 5.000000
s[0, 1] = 2.000000
save to delta[0, 0] = s[0, 1] = 1.000000
q[1] = s[1, 1] = 1.000000
q[0] = s[0, 1] = 2.000000
t[1, 4] = s[0, 4] = 5.000000
t[1, 3] = s[0, 3] = 4.000000
t[1, 2] = s[0, 2] = 3.000000
t[1, 1] = s[0, 1] = 2.000000
new Round B'
new Round C'
Right (2, 1, 0, 0) counter  = 74
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0] = 2.000000
case1 += delete B
case2_case2 = q[1] = 1.000000
case2 += insert A
case1 = 3.000000
case2 = 2.000000
case3 = 4.000000
Save to s[1, 0] = 2.000000
new Round C'
Right (0, 0, 0, 0) counter  = 75
case3 = 0
case1_case1 = s[1, 0] = 2.000000
case1 += delete A
case2_case2 = q[0] = 2.000000
case2 += insert A
case3_case3 delta[0, 0] = 1.000000
case3_case3 += A -> A = 0.000000
case1 = 3.000000
case2 = 3.000000
case3 = 1.000000
Save to s[0, 0] = 1.000000
t[0, 0] = s[0, 0] = 1.000000
