Compute Free(1, 0)
If select 1 in Tree A #Subproblem: 4 Direction: LeftCompute Free(1, 1)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[1][1] freeSumA = 0 freeSumB = 0
Free[1][1] = 1
FreeS(1, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(1, 2)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Leftfree[1][2] freeSumA = 0 freeSumB = 0
Free[1][2] = 1
FreeS(1, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
Compute Free(1, 3)
If select 1 in Tree A #Subproblem: 1 Direction: LeftCompute Free(1, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[1][3] freeSumA = 0 freeSumB = 0
Free[1][3] = 1
FreeS(1, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[1][0] freeSumA = 0 freeSumB = 3
LeftB[1, 1] = 1
Compute Free(1, 0)
If select 1(leftmost) in Tree B #Subproblem: 6 Direction: Right
bleftmost = 6
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -1 childrenSizeSumB[0] = 1
right = 3
Compute Free(1, 0)
If select 2 in Tree B #Subproblem: 6 Direction: Left
RightB(1, 3) = 1
brightmost = 6
Compute Free(1, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
Free[1][0] = 4
FreeS(1, 0)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
Compute Free(2, 0)
If select 2 in Tree A #Subproblem: 4 Direction: LeftCompute Free(2, 1)
If select 2 in Tree A #Subproblem: 1 Direction: LeftCompute Free(2, 1)
If select 1 in Tree B #Subproblem: 1 Direction: Leftfree[2][1] freeSumA = 0 freeSumB = 0
Free[2][1] = 1
FreeS(2, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(2, 2)
If select 2 in Tree A #Subproblem: 1 Direction: LeftCompute Free(2, 2)
If select 2 in Tree B #Subproblem: 1 Direction: Leftfree[2][2] freeSumA = 0 freeSumB = 0
Free[2][2] = 1
FreeS(2, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
Compute Free(2, 3)
If select 2 in Tree A #Subproblem: 1 Direction: LeftCompute Free(2, 3)
If select 3 in Tree B #Subproblem: 1 Direction: Leftfree[2][3] freeSumA = 0 freeSumB = 0
Free[2][3] = 1
FreeS(2, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[2][0] freeSumA = 0 freeSumB = 3
LeftB[2, 1] = 1
Compute Free(2, 0)
If select 1(leftmost) in Tree B #Subproblem: 6 Direction: Right
bleftmost = 6
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 3
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = -1 childrenSizeSumB[0] = 1
right = 3
Compute Free(2, 0)
If select 2 in Tree B #Subproblem: 6 Direction: Left
RightB(2, 3) = 1
brightmost = 6
Compute Free(2, 0)
If select 3(rightmost) in Tree B #Subproblem: 6 Direction: Left
Free[2][0] = 4
FreeS(2, 0)
Keynode: 2 in Tree A
Direction: rightLeaf: 2
Compute Free(0, 1)
If select 1 in Tree B #Subproblem: 3 Direction: Leftfree[0][1] freeSumA = 2 freeSumB = 0
LeftA[1, 1] = 1
Compute Free(0, 1)
If select 1(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(1, 1)(1) leftA(1, 1)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[2, 1] set to 2
arightmost = 4
Compute Free(0, 1)
If select 2(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[0][1] = 3
FreeS(0, 1)
Keynode: 1 in TreeB
Direction: rightLeaf: 1
Compute Free(0, 2)
If select 2 in Tree B #Subproblem: 3 Direction: Leftfree[0][2] freeSumA = 2 freeSumB = 0
LeftA[1, 2] = 1
Compute Free(0, 2)
If select 1(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(1, 2)(1) leftA(1, 2)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[2, 2] set to 2
arightmost = 4
Compute Free(0, 2)
If select 2(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[0][2] = 3
FreeS(0, 2)
Keynode: 2 in TreeB
Direction: rightLeaf: 2
Compute Free(0, 3)
If select 3 in Tree B #Subproblem: 3 Direction: Leftfree[0][3] freeSumA = 2 freeSumB = 0
LeftA[1, 3] = 1
Compute Free(0, 3)
If select 1(leftmost) in Tree A #Subproblem: 4 Direction: Right
free(1, 3)(1) leftA(1, 3)(1)  b->getLeftmostForestNum() = 1 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 4
RightA[2, 3] set to 2
arightmost = 4
Compute Free(0, 3)
If select 2(rightmost) in Tree A #Subproblem: 4 Direction: Left
Free[0][3] = 3
FreeS(0, 3)
Keynode: 3 in TreeB
Direction: rightLeaf: 3
free[0][0] freeSumA = 8 freeSumB = 9
LeftA[1, 0] = 6
Compute Free(0, 0)
If select 1(leftmost) in Tree A #Subproblem: 22 Direction: Right
free(1, 0)(4) leftA(1, 0)(6)  b->getLeftmostForestNum() = 6 a->getSubTreeSize() - childrenA[0]->getSubTreeSize()2
aleftmost = 22
RightA[2, 0] set to 2
arightmost = 22
Compute Free(0, 0)
If select 2(rightmost) in Tree A #Subproblem: 22 Direction: Left
LeftB[0, 1] = 4
Compute Free(0, 0)
If select 1(leftmost) in Tree B #Subproblem: 22 Direction: Right
bleftmost = 22
1 + childrenSizeSumB[1] = 2 childrenSizeSumB[2] - childrenSizeSumB[1] = 1
left = 12
1 + childrenSizeSumB[2] - childrenSizeSumB[1] = 1 childrenSizeSumB[0] = 1
right = 12
Compute Free(0, 0)
If select 2 in Tree B #Subproblem: 22 Direction: Left
RightB(0, 3) = 4
brightmost = 22
Compute Free(0, 0)
If select 3(rightmost) in Tree B #Subproblem: 22 Direction: Left
Free[0][0] = 22
FreeS(0, 0)
Keynode: 1 in Tree A
Direction: rightLeaf: 1
1 is a leaf
set S[1, 1] = 1
set S[1, 2] = 1
set S[1, 3] = 1
set S[1, 0] = 1
compute 1, 1
parent i = 0 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 1 = 1 tmpCost = 1.000000
right leaf(i) in 1 = 1 tmpCost = 1.000000
cost2_I[0] = -1.000000
S[1, 1] = 1
compute 1, 2
parent i = 0 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 1 = 1 tmpCost = 1.000000
right leaf(i) in 1 = 1 tmpCost = 1.000000
cost1_I[0, 0] = -1.000000
S[1, 2] = 2
compute 1, 3
parent i = 0 parent j = 0
left leaf(j) in 3 = 3 tmpCost = 1.000000
right leaf(j) in 3 = 3 tmpCost = 1.000000
left leaf(i) in 1 = 1 tmpCost = 1.000000
right leaf(i) in 1 = 1 tmpCost = 1.000000
cost2_I[0](-1.000000) += cost2_R[0](3.000000) = 2.000000
S[1, 3] = 3
compute 1, 0
parent i = 0 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 6.000000
right leaf(j) in 0 = 3 tmpCost = 6.000000
cost1_I[0, 0] = -6.000000
S[1, 0] = 1
2 is a leaf
set S[2, 1] = 2
set S[2, 2] = 2
set S[2, 3] = 2
set S[2, 0] = 2
compute 2, 1
parent i = 0 parent j = 0
left leaf(j) in 1 = 1 tmpCost = 1.000000
right leaf(j) in 1 = 1 tmpCost = 1.000000
left leaf(i) in 2 = 2 tmpCost = 1.000000
right leaf(i) in 2 = 2 tmpCost = 1.000000
cost1_I[0, 1](-32761103880258910607638528.000000) += cost1_R[2, 1](-32761103880258910607638528.000000) = -65522207760517821215277056.000000
cost2_I[0] = -1.000000
S[2, 1] = 1
compute 2, 2
parent i = 0 parent j = 0
left leaf(j) in 2 = 2 tmpCost = 1.000000
right leaf(j) in 2 = 2 tmpCost = 1.000000
left leaf(i) in 2 = 2 tmpCost = 1.000000
right leaf(i) in 2 = 2 tmpCost = 1.000000
cost1_I[0, 2](-1.000000) += cost1_R[2, 2](2.000000) = 1.000000
S[2, 2] = 2
compute 2, 3
parent i = 0 parent j = 0
left leaf(j) in 3 = 3 tmpCost = 1.000000
right leaf(j) in 3 = 3 tmpCost = 1.000000
left leaf(i) in 2 = 2 tmpCost = 1.000000
right leaf(i) in 2 = 2 tmpCost = 1.000000
cost1_I[0, 3](-32761103880258910607638528.000000) += cost1_R[2, 3](-32761103880258910607638528.000000) = -65522207760517821215277056.000000
cost2_I[0](-1.000000) += cost2_R[0](3.000000) = 2.000000
S[2, 3] = 3
compute 2, 0
parent i = 0 parent j = NULL
left leaf(j) in 0 = 1 tmpCost = 6.000000
right leaf(j) in 0 = 3 tmpCost = 6.000000
cost1_I[0, 0](-6.000000) += cost1_R[2, 0](12.000000) = 6.000000
S[2, 0] = 1
compute 0, 1
parent i = NULL parent j = 0
left leaf(i) in 0 = 1 tmpCost = 4.000000
right leaf(i) in 0 = 2 tmpCost = 4.000000
cost2_I[0] = -4.000000
S[0, 1] = 1
compute 0, 2
parent i = NULL parent j = 0
left leaf(i) in 0 = 1 tmpCost = 4.000000
right leaf(i) in 0 = 2 tmpCost = 4.000000
S[0, 2] = 1
compute 0, 3
parent i = NULL parent j = 0
left leaf(i) in 0 = 1 tmpCost = 4.000000
right leaf(i) in 0 = 2 tmpCost = 4.000000
cost2_I[0](-4.000000) += cost2_R[0](12.000000) = 8.000000
S[0, 3] = 1
compute 0, 0
parent i = NULL parent j = NULL
left leaf(i) in 0 = 1 tmpCost = 24.000000
right leaf(i) in 0 = 2 tmpCost = 24.000000
special leaf(i) in 0 = 1 tmpCost = 27.000000 cost1_I[0, 0] = 6.000000
left leaf(j) in 0 = 1 tmpCost = 24.000000
right leaf(j) in 0 = 3 tmpCost = 24.000000
special leaf(j) in 0 = 1 tmpCost = 24.000000 cost2_I[0] = 8
S[0, 0] = 1
RESULT
1 in A 1 in B 2 in B 3 in B 
1 in A 1 in B 2 in B 3 in B 
2 in A 1 in B 2 in B 3 in B 
RESULT 2
1 in A 1 in A 1 in A 1 in A 
1 in B 1 in B 2 in B 3 in B 
1 in B 1 in B 2 in B 3 in B 
Distance Matrix
- 0
A 1
B 5
C 3
D 6
E 7
F 8
G 2
H 9
I 10
J 11
K 12
L 13
M 14
N 15
O 16
P 17
Q 18
R 19
S 20
U 4
0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 0.000000 
1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.000000 

gted(0, 0)
hasVisited[0, 0] = 0
treeSizeA = 3
treeSizeB = 4
getPathType A(0 ,1) = 0
A child = 1 currentPathNode = 1 parent = 0
A child = 2 currentPathNode = 1 parent = 0
gted(0, 0) create problem in A gted(2, 0)
gted(2, 0)
hasVisited[2, 0] = 0
treeSizeA = 1
treeSizeB = 4
cost = 4.000000
change F -> A from insert A nodeRenMinusIns = 0.000000
change F -> B from insert B nodeRenMinusIns = 0.000000
change F -> C from insert C nodeRenMinusIns = 0.000000
change F -> D from insert D nodeRenMinusIns = 0.000000
spf1(2, 0) = 4
swap = false pathType = 0
spfA_RL(0, 0) 0 
new Round B'
new Round C'
Right (1, 2, 3, 1) counter  = 5
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert D
case3_case3 delta[1, 3] = 0.000000
case3_case3 += E -> D = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
Save to s[2, 1] = 1.000000
t[3, 1] = s[2, 1] = 1.000000
new Round B'
new Round C'
Right (1, 2, 2, 2) counter  = 6
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert C
case3_case3 delta[1, 2] = 0.000000
case3_case3 += E -> C = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
Save to s[2, 2] = 1.000000
t[2, 2] = s[2, 2] = 1.000000
new Round B'
new Round C'
Right (1, 2, 1, 3) counter  = 7
case3 = 0
case1_case3 = GcurrentForestCost = 1
case1 += delete F
case2_case1 = 1.000000
case2 += insert B
case3_case3 delta[1, 1] = 0.000000
case3_case3 += E -> B = 1.000000
case1 = 2.000000
case2 = 2.000000
case3 = 1.000000
Save to s[2, 3] = 1.000000
Right (1, 2, 1, 2) counter = 8
Save to s[2, 2]
case1_case3 GcurrentForestCost = 2 + delete F
case2_case3 s[2, 3] = 1.000000 + insert C
case3_case delta[1, 2] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 2.000000 - 1
case3 += E -> C
case1 = 3.000000
case2 = 2.000000
case3 = 2.000000
s[2, 2] = 2.000000
Right (1, 2, 1, 1) counter = 9
Save to s[2, 1]
case1_case3 GcurrentForestCost = 3 + delete F
case2_case3 s[2, 2] = 2.000000 + insert D
case3_case delta[1, 3] = 0.000000
case3_case2 += GcurrentForestCost - G(rG) = 3.000000 - 1
case3 += E -> D
case1 = 4.000000
case2 = 3.000000
case3 = 3.000000
s[2, 1] = 3.000000
q[2] = s[2, 1] = 3.000000
t[1, 3] = s[2, 3] = 1.000000
t[1, 2] = s[2, 2] = 2.000000
t[1, 1] = s[2, 1] = 3.000000
new Round B'
new Round C'
Right (1, 2, 0, 0) counter  = 10
case3 = 0
case1_case3 = GcurrentForestCost = 4
case1 += delete F
case2_case2 = q[2] = 3.000000
case2 += insert A
case3_case3 delta[1, 0] = 3.000000
case3_case3 += E -> A = 1.000000
case1 = 5.000000
case2 = 4.000000
case3 = 4.000000
Save to s[2, 0] = 4.000000
t[0, 0] = s[2, 0] = 4.000000
new Round B'
new Round C'
Right (1, 1, 3, 1) counter  = 11
case3_case FcurrentForest - F(rF)
case1_case2 = t[3, 1] = 1.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert D
case3_case3 delta[2, 3] = 0.000000
case3_case3 += F -> D = 1.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
Save to s[1, 1] = 2.000000
new Round C'
Right (0, 0, 3, 1) counter  = 12
case3 = 0
case1_case1 = s[1, 1] = 2.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert D
case3_case3 delta[0, 3] = 2.000000
case3_case3 += C -> D = 1.000000
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
Save to s[0, 1] = 3.000000
t[3, 1] = s[0, 1] = 3.000000
new Round B'
new Round C'
Right (1, 1, 2, 2) counter  = 13
case3_case FcurrentForest - F(rF)
case1_case2 = t[2, 2] = 1.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert C
case3_case3 delta[2, 2] = 0.000000
case3_case3 += F -> C = 1.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
Save to s[1, 2] = 2.000000
new Round C'
Right (0, 0, 2, 2) counter  = 14
case3 = 0
case1_case1 = s[1, 2] = 2.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert C
case3_case3 delta[0, 2] = 2.000000
case3_case3 += C -> C = 0.000000
case1 = 3.000000
case2 = 4.000000
case3 = 2.000000
Save to s[0, 2] = 2.000000
t[2, 2] = s[0, 2] = 2.000000
new Round B'
new Round C'
Right (1, 1, 1, 3) counter  = 15
case3_case FcurrentForest - F(rF)
case1_case2 = t[1, 3] = 1.000000
case1 += delete E
case2_case1 = 2.000000
case2 += insert B
case3_case3 delta[2, 1] = 0.000000
case3_case3 += F -> B = 1.000000
case1 = 2.000000
case2 = 3.000000
case3 = 2.000000
Save to s[1, 3] = 2.000000
Right (1, 1, 1, 2) counter = 16
Save to s[1, 2]
case1_case2 t[1, 2] = 2.000000 + delete E
case2_case3 s[1, 3] = 2.000000 + insert C
case3_case delta[2, 2] = 0.000000
case3_case3 += t[1, 3] = 1.000000
case3 += F -> C
case1 = 3.000000
case2 = 3.000000
case3 = 2.000000
s[1, 2] = 2.000000
Right (1, 1, 1, 1) counter = 17
Save to s[1, 1]
case1_case2 t[1, 1] = 3.000000 + delete E
case2_case3 s[1, 2] = 2.000000 + insert D
case3_case delta[2, 3] = 0.000000
case3_case3 += t[1, 2] = 2.000000
case3 += F -> D
case1 = 4.000000
case2 = 3.000000
case3 = 3.000000
s[1, 1] = 3.000000
new Round C'
Right (0, 0, 1, 3) counter  = 18
case3 = 0
case1_case1 = s[1, 3] = 2.000000
case1 += delete C
case2_case1 = 3.000000
case2 += insert B
case3_case3 delta[0, 1] = 2.000000
case3_case3 += C -> B = 1.000000
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
Save to s[0, 3] = 3.000000
Right (0, 0, 1, 2) counter = 19
Save to s[0, 2]
case1_case1 s[1, 2] = 2.000000 + delete C
case2_case3 s[0, 3] = 3.000000 + insert C
case3_case delta[0, 2] = 2.000000
case3_case2 += GcurrentForestCost - G(rG) = 2.000000 - 1
case1 = 3.000000
case2 = 4.000000
case3 = 3.000000
s[0, 2] = 3.000000
Right (0, 0, 1, 1) counter = 20
Save to s[0, 1]
case1_case1 s[1, 1] = 3.000000 + delete C
case2_case3 s[0, 2] = 3.000000 + insert D
case3_case delta[0, 3] = 2.000000
case3_case2 += GcurrentForestCost - G(rG) = 3.000000 - 1
case1 = 4.000000
case2 = 4.000000
case3 = 4.000000
s[0, 1] = 4.000000
save to delta[0, 0] = s[0, 1] = 3.000000
q[1] = s[1, 1] = 3.000000
q[0] = s[0, 1] = 4.000000
t[1, 3] = s[0, 3] = 3.000000
t[1, 2] = s[0, 2] = 3.000000
t[1, 1] = s[0, 1] = 4.000000
new Round B'
new Round C'
Right (1, 1, 0, 0) counter  = 21
case3_case FcurrentForest - F(rF)
case1_case2 = t[0, 0] = 4.000000
case1 += delete E
case2_case2 = q[1] = 3.000000
case2 += insert A
case3_case3 delta[2, 0] = 3.000000
case1 = 5.000000
case2 = 4.000000
case3 = 4.000000
Save to s[1, 0] = 4.000000
new Round C'
Right (0, 0, 0, 0) counter  = 22
case3 = 0
case1_case1 = s[1, 0] = 4.000000
case1 += delete C
case2_case2 = q[0] = 4.000000
case2 += insert A
case3_case3 delta[0, 0] = 3.000000
case3_case3 += C -> A = 1.000000
case1 = 5.000000
case2 = 5.000000
case3 = 4.000000
Save to s[0, 0] = 4.000000
t[0, 0] = s[0, 0] = 4.000000
